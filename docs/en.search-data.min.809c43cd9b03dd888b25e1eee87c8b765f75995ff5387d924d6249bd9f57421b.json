[{"id":0,"href":"/4.concurrent/channel/","title":"channel","section":"4.concurrents","content":"channel #  channel 是goroutine 之间互相通讯的东西。类似我们 Unix 上的管道（可以在进程间传递消息），用来 goroutine 之间发消息和接收消息。其实，就是在做 goroutine 之间的内存共享。channel 是类型相关的，也就是说一个 channel 只能传递一种类型的值，这个类型需要在 channel 声明时指定。\n声明与初始化 #  channel 的一般声明形式：var chanName chan ElementType。\n与普通变量的声明不同的是在类型前面加了 channel 关键字，ElementType 则指定了这个 channel 所能传递的元素类型。示例：\nvar a chan int //声明一个传递元素类型为int的channel var b chan float64 var c chan string 初始化一个 channel 也非常简单，直接使用 Go 语言内置的 make() 函数，示例：\na := make(chan int) //初始化一个int型的名为a的channel b := make(chan float64) c := make(chan string) channel 最频繁的操作就是写入和读取，这两个操作也非常简单，示例：\na := make(chan int) a \u0026lt;- 1 //将数据写入channel z := \u0026lt;-a //从channel中读取数据 "},{"id":1,"href":"/4.concurrent/select/","title":"select","section":"4.concurrents","content":"select #  select 用于处理异步 IO 问题，它的语法与 switch 非常类似。由 select 开始一个新的选择块，每个选择条件由 case 语句来描述，并且每个 case 语句里必须是一个 channel 操作。它既可以用于 channel 的数据接收，也可以用于 channel 的数据发送。如果 select 的多个分支都满足条件，则会随机的选取其中一个满足条件的分支。\n新建源文件 channel.go，输入以下代码：\nfunc main() { c1 := make(chan string) c2 := make(chan string) go func() { time.Sleep(time.Second * 1) c1 \u0026lt;- \u0026#34;one\u0026#34; }() go func() { time.Sleep(time.Second * 2) c2 \u0026lt;- \u0026#34;two\u0026#34; }() start := time.Now() // 获取当前时间  for i := 0; i \u0026lt; 2; i++ { select { case msg1 := \u0026lt;-c1: fmt.Println(\u0026#34;received\u0026#34;, msg1) case msg2 := \u0026lt;-c2: fmt.Println(\u0026#34;received\u0026#34;, msg2) } } elapsed := time.Since(start) // 这里没有用到3秒，为什么？ \tfmt.Println(\u0026#34;该函数执行完成耗时：\u0026#34;, elapsed) } 以上代码先初始化两个 channel c1 和 c2，然后开启两个 goroutine 分别往 c1 和 c2 写入数据，再通过 select 监听两个 channel，从中读取数据并输出。\n运行结果如下：\n$ go run channel.go received one received two "},{"id":2,"href":"/4.concurrent/timeout/","title":"timeout","section":"4.concurrents","content":"timeout #  超时机制 #  通过前面的内容我们了解到，channel 的读写操作非常简单，只需要通过 \u0026lt;- 操作符即可实现，但是 channel 的使用不当却会带来大麻烦。我们先来看之前的一段代码：\na := make(chan int) a \u0026lt;- 1 z := \u0026lt;-a 观察上面三行代码，第 2 行往 channel 内写入了数据，第 3 行从 channel 中读取了数据，如果程序运行正常当然不会出什么问题，可如果第二行数据写入失败，或者 channel 中没有数据，那么第 3 行代码会因为永远无法从 a 中读取到数据而一直处于阻塞状态。\n相反的，如果 channel 中的数据一直没有被读取，那么写入操作也会一直处于阻塞状态。如果不正确处理这个情况，很可能会导致整个 goroutine 锁死，这就是超时问题。Go 语言没有针对超时提供专门的处理机制，但是我们却可以利用 select 来巧妙地实现超时处理机制，下面看一个示例：\nt := make(chan bool) go func() { time.Sleep(1e9) //等待1秒  t \u0026lt;- true }() select { case \u0026lt;-ch: //从ch中读取数据  case \u0026lt;-t: //如果1秒后没有从ch中读取到数据，那么从t中读取，并进行下一步操作 } 这样的方法就可以让程序在等待 1 秒后继续执行，而不会因为 ch 读取等待而导致程序停滞，从而巧妙地实现了超时处理机制，这种方法不仅简单，在实际项目开发中也是非常实用的。\nchannel 的关闭 #  channel 的关闭非常简单，使用 Go 语言内置的 close() 函数即可关闭 channel，示例：\nch := make(chan int) close(ch) 关闭了 channel 后如何查看 channel 是否关闭成功了呢？很简单，我们可以在读取 channel 时采用多重返回值的方式，示例：\nx, ok := \u0026lt;-ch 通过查看第二个返回值的 bool 值即可判断 channel 是否关闭，若为 false 则表示 channel 被关闭，反之则没有关闭。\n建议使用 defer 如下\nt := make(chan bool) ch := make(chan int) defer func() { close(ch) close(t) }()  完整代码\npackage main import \u0026#34;time\u0026#34; func main() { t := make(chan bool) ch := make(chan int) defer func() { close(ch) close(t) }() go func() { time.Sleep(1e9) //等待1秒 \tt \u0026lt;- true }() go func() { time.Sleep(time.Second * 2) ch \u0026lt;- 123 }() select { case \u0026lt;-ch: //从ch中读取数据  case \u0026lt;-t: //如果1秒后没有从ch中读取到数据，那么从t中读取，并进行下一步操作 \t} } "},{"id":3,"href":"/a.timer/reset/readme/","title":"可热更新的定时器","section":"A.timers","content":"可热更新的定时器 #  废话不多说，直接上代码\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type Server struct { tk *time.Ticker reset chan struct{} Close chan struct{} Period int64 } func main() { s := CreateServer(1) go s.Start() time.Sleep(time.Duration(10) * time.Second) s.Update(3) time.Sleep(time.Duration(10) * time.Second) s.Stop() fmt.Println(\u0026#34;good bye\u0026#34;) } func CreateServer(Period int64) *Server { return \u0026amp;Server{ tk: nil, reset: make(chan struct{}), Close: make(chan struct{}), Period: Period, } } // 程序启动 func (s *Server) Start() { // 定时 \ts.tk = time.NewTicker(time.Duration(s.Period) * time.Second) defer s.tk.Stop() for { select { case \u0026lt;-s.Close: return case \u0026lt;-s.tk.C: fmt.Println(\u0026#34;定时唤醒:\u0026#34;, time.Now().Format(\u0026#34;2006-01-02 15:04:05\u0026#34;)) case \u0026lt;-s.reset: s.tk.Stop() s.tk = time.NewTicker(time.Duration(s.Period) * time.Second) } } } func (s *Server) Stop() { close(s.Close) close(s.reset) } func (s *Server) Update(p int64) { s.Period = p s.reset \u0026lt;- struct{}{} } "},{"id":4,"href":"/1.base/1-1-install-download/","title":"1 1 Install Download","section":"1.bases","content":"1.1 安装和下载 #  1.1.1 下载位置 #   go语言中文网\n1.1.2 如何安装 #  为你的系统下载了相应的安装包后，请按照 安装说明 进行安装。\n如果你选择从源码构建，请参考 从源码进行安装 。\n查看 发布历史 了解更多关于 Go 各版本的发布说明。\n1.1.3 小结 #  安装其实很容易，如果出现什么安装问题欢迎留言\n"},{"id":5,"href":"/1.base/1-2-hello-world/","title":"1 2 Hello World","section":"1.bases","content":"1.2.1 hello world #  Go 语言是谷歌 2009 发布的第二款开源编程语言。\nGo 语言专门针对多处理器系统应用程序的编程进行了优化，使用 Go 编译的程序可以媲美 C 或 C++代码的速度，而且更加安全、支持并行进程。\n1.2.1 为什么要选择学习 Go 语言呢？与其他语言的应用相比，它有什么优点呢？ #  1、学习曲线它包含了类 C 语法、GC 内置和工程工具。这一点非常重要，因为 Go 语言容易学习，所以一个普通的大学生花一个星期就能写出来可以上手的、高性能的应用。在国内大家都追求快，这也是为什么国内 Go 流行的原因之一。\n2、效率 Go 拥有接近 C 的运行效率和接近 PHP 的开发效率，这就很有利的支撑了上面大家追求快速的需求。\n3、出身名门、血统纯正之所以说 Go 语言出身名门，是因为我们知道 Go 语言出自 Google 公司，这个公司在业界的知名度和实力自然不用多说。Google 公司聚集了一批牛人，在各种编程语言称雄争霸的局面下推出新的编程语言，自然有它的战略考虑。而且从 Go 语言的发展态势来看，Google 对它这个新的宠儿还是很看重的，Go 自然有一个良好的发展前途。我们看看 Go 语言的主要创造者，血统纯正这点就可见端倪了。\n4、自由高效：组合的思想、无侵入式的接口 Go 语言可以说是开发效率和运行效率二者的完美融合，天生的并发编程支持。Go 语言支持当前所有的编程范式，包括过程式编程、面向对象编程以及函数式编程。程序员们可以各取所需、自由组合、想怎么玩就怎么玩。\n5、强大的标准库这包括互联网应用、系统编程和网络编程。Go 里面的标准库基本上已经是非常稳定了，特别是我这里提到的三个，网络层、系统层的库非常实用。\n6、部署方便：二进制文件、Copy 部署我相信这一点是很多人选择 Go 的最大理由，因为部署太方便了，所以现在也有很多人用 Go 开发运维程序。\n7、简单的并发它包含了降低心智的并发和简易的数据同步，我觉得这是 Go 最大的特色。之所以写正确的并发、容错和可扩展的程序如此之难，是因为我们用了错误的工具和错误的抽象，Go 可以说这一块做的相当简单。\n8、稳定性 Go 拥有强大的编译检查、严格的编码规范和完整的软件生命周期工具，具有很强的稳定性，稳定压倒一切。那么为什么 Go 相比于其他程序会更稳定呢？这是因为 Go 提供了软件生命周期（开发、测试、部署、维护等等）的各个环节的工具，如 go tool、gofmt、go test。\n1.2.2 Go 语言适合用来做什么？ #  服务器编程：以前你如果使用 C 或者 C++做的那些事情，用 Go 来做很合适，例如处理日志、数据打包、虚拟机处理、文件系统等。\n分布式系统：数据库代理器等。\n网络编程：这一块目前应用最广，包括 Web 应用、API 应用、下载应用、内存数据库。\n云平台：google 开发的 groupcache，couchbase 的部分组建云平台，目前国外很多云平台在采用 Go 开发，CloudFoundy 的部分组建，前 VMare 的技术总监自己出来搞的 apcera 云平台。\n1.2.3 Go 语言成功的项目 #  nsq：bitly 开源的消息队列系统，性能非常高，目前他们每天处理数十亿条的消息\ndocker：基于 lxc 的一个虚拟打包工具，能够实现 PAAS 平台的组建\npacker：用来生成不同平台的镜像文件，例如 VM、vbox、AWS 等，作者是 vagrant 的作者\nskynet：分布式调度框架\nDoozer：分布式同步工具，类似 ZooKeeper\nHeka：mazila 开源的日志处理系统\ncbfs：couchbase 开源的分布式文件系统\ntsuru：开源的 PAAS 平台，和 SAE 实现的功能一模一样\ngroupcache：memcahe 作者写的用于 Google 下载系统的缓存系统\ngod：类似 redis 的缓存系统，但是支持分布式和扩展性\ngor：网络流量抓包和重放工具\n1.2.4 哪些大公司在用 go 语言？ #  Google\n这个不用多做介绍，作为开发 Go 语言的公司，当仁不让。Google 基于 Go 有很多优秀的项目，比如：https://github.com/kubernetes/kubernetes ，大家也可以在 Github 上 https://github.com/google/ 查看更多 Google 的 Go 开源项目。\nFacebook\nFacebook 也在用，为此他们还专门在 Github 上建立了一个开源组织 facebookgo，大家可以通过 https://github.com/facebookgo 访问查看 facebook 开源的项目，比如著名的是平滑升级的 grace。腾讯\n腾讯作为国内的大公司，还是敢于尝试的，尤其是 Docker 容器化这一块，他们在 15 年已经做了 docker 万台规模的实践，具体可以参考 http://www.infoq.com/cn/articles/tencent-millions-scale-docker-application-practice\n百度\n目前所知的百度的使用是在运维这边，是百度运维的一个 BFE 项目，负责前端流量的接入。他们的负责人在 2016 年有分享，大家可以看下这个 http://www.infoq.com/cn/presentations/application-of-golang-in-baidu-frontend\n阿里\n阿里巴巴具体的项目不太清楚，不过听说其系统部门、CDN 等正在招 Go 方面的人。京东\n京东云消息推送系统、云存储，以及京东商城等都有使用 Go 做开发。\n小米\n小米对 Golang 的支持，莫过于运维监控系统的开源，也就是 http://open-falcon.com/\n此外，小米互娱、小米商城、小米视频、小米生态链等团队都在使用Golang。\n360\n360 对 Golang 的使用也不少，一个是开源的日志搜索系统 Poseidon，托管在 Github 上，https://github.com/Qihoo360/poseidon\nGo语言前景：\n  （以上数据来源于网络）\n1.2.5 第一个 go 程序 #  带着目标学东西往往是最有成效的，为什么学以及环境安装可以参考前面的文章。\nlet\u0026rsquo;s go go go !\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } 这是一个最简单的 go 程序，由三个元素构成\n元素一、包 ：package是包，每个文件夹是一个包，默认包名就是文件夹名，文件夹下所有的.go文件全部都是同一个包。\nmain包整个项目的入口，你可以在指定任意一个文件夹当作程序的入口，然后把里面所有文件第一行改成package main，也可以把项目根目录当作main包。\nPS: 每个项目默认有且只有一个main包\n元素二、import：这个关键字代表引入其他地方的包，可以是当前项目的，也可以是别人写的。 这里import \u0026quot;fmt\u0026quot;引入的就是 go 原生的fmt包，专门用来输出文本的。\n元素三、语句\nfunc main() { fmt.Println(\u0026#34;Hello, World!\u0026#34;) } main 入口函数，每个项目只有一个main函数\n执行以上代码输出\n$ go run hello.go Hello, World! 1.2.6 让你的项目在IDE里跑起来 #  每次新建项目，不熟悉go的项目结构，一般跑都跑不起来，每次都要重新搞一遍，好几回跑项目都会报类似File is invalid的错误\n 有时候报其他奇怪的错误，今天就下决心整理一下，理一理概念 GOROOT、GOPATH、src、 pkg、bin，希望以后不要再出现这样的问题了，同时给看到文章的你一些帮助。\n1.2.6.1 熟悉golang项目目录结构 #  要想让你的程序跑起来，要按照这样的目录结构，正常情况下有三个目录：\n|--bin |--pkg |--src 其中，bin存放编译后的可执行文件；pkg存放编译后的包文件；src存放项目源文件。一般，bin和pkg目录可以不创建，go命令会自动创建（爽否？），只需要创建src目录放代码即可。\n我创建一个src目录，下面再创建一个叫main的项目（可以叫任何名字，我只是示例叫main），里面只有一个main.go文件。\n 他的内容是：\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;hello world\u0026#34;) }  本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/1.base/1.2-hello-world\n 这样一个简单的项目就创建好了，创建好只是第一步，下面让她跑起来。\n1.2.6.2 让她跑起来 #  找到配置，Goland里面大多数的配置都在这里。\n 配置你的GOROOT，配置成你安装的go路径，Goland会自动识别，这就是GOROOT的作用，和JAVA_HOME的作用差不多。\n 配置GOPATH，你的项目放在src下面不是随随便便就放的，得让go知道你这些个项目基于哪个位置。\n 细心的人注意到，这里有一个Project GOPATH，还有一个Global GOPATH,把你的项目配置在Project GOPATH里，每个项目都不一样，创建另一个项目时这个路径要配置成新项目的。\nGlobal GOPATH可以弄一个公共项目，以后就把第三方的包直接装到这里，就可以自动在你的项目里引用了。\n调出ToolBar，开始配置运行文件\n 在ToolBar中Add Configuration\n 创建一个go build，可以看到有一个go remote的选项，它是用来调试远程服务器上的代码的，有兴趣关注我，我后续更新。\n 注意这三个位置，\n选File，运行文件就选main函数所在在文件main.go，输出文件夹就在和src同级目录的bin文件夹（自动创建）,Working directory目录就是刚刚设置GOPATH的目录（自动）\n 注意，如果你多次打开目录选择，框框里的目录不会被替换掉，而是追加，导致运行的时候报错，除非你想一次性编译多个项目。\n例如这样：\n/Users/pzqu/Documents/code/go/what_go/src/main/main.go|/Users/pzqu/Documents/code/go/what_go/src/main/main.go  点击OK保存，之后，在ToolBar上点击运行，旁边那个符号是debug\n 成功运行！自动创建了bin目录\n 如果你想改输出的二进制文件名，可以在这里添加参数-o bin/main\n 1.2.7 如何在一个项目中使用其他项目？ #  1.2.7.1 引用自己的项目中的其他模块包 #  写一个新函数func Add(a, b int) int,放在src下面main项目，calc文件夹，add.go文件里\n|____src | |____main | | |____calc | | | |____add.go | | |____main.go 代码如下\npackage calc func Add(a, b int) int { return a + b } 在main函数中调用他\n 输出结果：\n 几个点需要注意：\n  add.go中的Add函数名首字母必须大写， 比如Add, Addxxx.只有大写的才是Public权限，外面的包才能访问，否则只能自己文件夹下代码才能访问\n  add.go的改名为addyyy.go也可以，查找add包的时候，并不会根据add.go这个文件名来查找。而是根据文件夹名来查找，一个文件夹下的所有文件都属于同一个包。所以函数变量自然不能重复。\n  main中调用add.Add(1,2)时，add是包， 必须跟add.go中的package处的包名一致，否则报错。\n  import后， 怎么去查找对应的包呢？ 思考一下， 很简单，无非就是GOROOT和GOPATH. 也应该明白了， src这个目录名可不是能随便取的。\n  1.2.7.2 引用第三方项目 #  自己写的其他项目引入，比如我这有一个叫common的公共包，你的公司有可能把很多go包下载下来，做一个公共仓库，方便公司内网隔离。\n 代码很简单\npackage dance import \u0026#34;fmt\u0026#34; func WhoDance() { fmt.Println(\u0026#34;you\u0026#34;) } 在main里面调用\npackage main import \u0026#34;common/dance\u0026#34; func main() { dance.WhoDance() } 输出\nyou Process finished with exit code 0 还有一个相当好用的引用第三方项目的工具，vendor关注我的博客，我们后续再见。\n1.2.8 小结 #  通过这一节，你已经了解到了go语言的历史和前景，并了解到怎么在IDE里跑起来go项目。这是一切的开始，算是进入了go语言的大门，在接下来的日子希望我们可以愉快的走下去。\n1.2.9 参考 #   小议并实战go包\u0026mdash;\u0026mdash;顺便说说go中的GOROOT,GOPATH和src,pkg,bin\n"},{"id":6,"href":"/1.base/1-3-go-mod/","title":"1 3 Go Mod","section":"1.bases","content":"1.3 go mod最佳实践 #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/1.base/1.3-go-mod\n java 里有一个叫 maven 的包管理工具， go 也有一个叫 go mod 的管理工具，可以管理项目引用的第三方包版本、自动识别项目中用到的包、自动下载和管理包。\n为什么要使用go mod？\n 使用go mod仓库中可以不用再上传依赖代码包，防止代码仓库过大浪费以及多个项目同时用包时的浪费 可以管理引用包的版本，这一点是gopath（src模式）和vendor做不到的 如果依赖gopath不同项目如果引用了同一个软件包的不同版本，就会造成编译麻烦  gopath是go之前的默认策略，每个项目在运行时都要严格放在src目录下，而go mod不用\n原来的包管理方式\n 在不使用额外的工具的情况下，Go 的依赖包需要手工下载， 第三方包没有版本的概念，如果第三方包的作者做了不兼容升级，会让开发者很难受 协作开发时，需要统一各个开发成员本地$GOPATH/src下的依赖包 引用的包引用了已经转移的包，而作者没改的话，需要自己修改引用。 第三方包和自己的包的源码都在src下，很混乱。对于混合技术栈的项目来说，目录的存放会有一些问题  新的包管理模式解决了以上问题\n 自动下载依赖包 项目不必放在$GOPATH/src内了 项目内会生成一个go.mod文件，列出包依赖 所以来的第三方包会准确的指定版本号 对于已经转移的包，可以用 replace 申明替换，不需要改代码  1.3.1 配置 #  golang\u0026gt;=1.12 添加环境变量 GO111MODULE 为 on 或者 auto ，设置方法\ngo env GO111MODULE=on go env -w GO111MODULE=\u0026#34;on\u0026#34; go env -w GOPROXY=https://goproxy.io go mod init 项目名 go mod tidy #add missing and remove unused modules  打开go mod 模式 使用国内下载包代理 初始化mod项目 自动增加包和删除无用包到 GOPATH 目录下（build的时候也会自动下载包加入到go.mod里面的）  注意：只要在本地设置一个公用path目录就可以了，全部的包都会下载到那里，其他本地项目用到时就可以共享了\n自动生成了go.mod和go.sum文件，可以不用理会，下面是简单介绍\n1.3.2 go.mod 文件 #  go.mod 的内容比较容易理解\n 第一行：模块的引用路径 第二行：项目使用的 go 版本 第三行：项目所需的直接依赖包及其版本  在实际应用上，你会看见更复杂的 go.mod 文件，比如下面这样\nmodule github.com/BingmingWong/module-test go 1.14 require ( example.com/apple v0.1.2 example.com/banana v1.2.3 example.com/banana/v2 v2.3.4 example.com/pear // indirect example.com/strawberry // incompatible ) exclude example.com/banana v1.2.4 replace（ golang.org/x/crypto v0.0.0-20180820150726-614d502a4dac = \u0026gt; github.com/golang/crypto v0.0.0-20180820150726-614d502a4dac golang.org/x/net v0.0.0-20180821023952-922f4815f713 = \u0026gt; github.com/golang/net v0.0.0-20180826012351-8a410e7b638d golang.org/x/text v0.3.0 = \u0026gt; github.com/golang/text v0.3.0 ) 主要是多出了两个 flag：\n exclude：忽略指定版本的依赖包 replace：由于在国内访问golang.org/x的各个包都需要翻墙，你可以在go.mod中使用replace替换成github上对应的库。  1.3.3 go.sum 文件 #  每一行都是由 模块路径，模块版本，哈希检验值 组成，其中哈希检验值是用来保证当前缓存的模块不会被篡改。hash 是以h1:开头的字符串，表示生成checksum的算法是第一版的hash算法（sha256）。\n值得注意的是，为什么有的包只有一行\n\u0026lt;module\u0026gt; \u0026lt;version\u0026gt;/go.mod \u0026lt;hash\u0026gt; 而有的包却有两行呢\n\u0026lt;module\u0026gt; \u0026lt;version\u0026gt; \u0026lt;hash\u0026gt; \u0026lt;module\u0026gt; \u0026lt;version\u0026gt;/go.mod \u0026lt;hash\u0026gt; 那些有两行的包，区别就在于 hash 值不一行，一个是 h1:hash，一个是 go.mod h1:hash\n而 h1:hash 和 go.mod h1:hash两者，要不就是同时存在，要不就是只存在 go.mod h1:hash。那什么情况下会不存在 h1:hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的h1 hash，就会出现不存在 h1 hash，只存在 go.mod h1:hash 的情况。[引用自 3]\ngo.mod 和 go.sum 是 go modules 版本管理的指导性文件，因此 go.mod 和 go.sum 文件都应该提交到你的 Git 仓库中去，避免其他人使用你写项目时，重新生成的go.mod 和 go.sum 与你开发的基准版本的不一致。\n1.3.4 go mod 命令的使用 #  go mod init：初始化go mod， 生成go.mod文件，后可接参数指定 module 名，上面已经演示过。\ngo mod download：手动触发下载依赖包到本地cache（默认为$GOPATH/pkg/mod目录）\ngo mod graph：打印项目的模块依赖结构\n图片 go mod tidy ：添加缺少的包，且删除无用的包\ngo mod verify ：校验模块是否被篡改过\ngo mod why：查看为什么需要依赖\ngo mod vendor ：导出项目所有依赖到vendor下\n写入go.mod有两种方法：\n 你只要在项目中有 import 并使用或者使用下划线强制占用，然后 go build 就会 go module 就会自动下载并添加。 go mod tidy  1.3.5 vendor是什么 #  vendor是项目缓存，为了防止开源代码项目被删除无法引用下载，会使用vendor来做缓存管理，它是独立的，你可以手动管理引用的包，代码包查找的顺序是向上冒泡\n包同目录下的vendor 包目录向上的最近的一个vendor ... GOPATH src 下的vendor GOROOT src GOPATH src 这样的话， 我们可以把包的依赖都放在 vendor 下，然后提交到仓库，这样可以省却拉取包的时间，并且相对自由，你想怎么改都可以\n1.3.6 最佳实践 #  go mod 只是一个依赖包版本管理工具，包的查找顺序还是一样的，使用mod就不用把代码都放到src下来管理，可以根据go.mod文件中记录的版本来索引\n我建议：\n 使用mod管理版本，并使用go vendor来cache依赖包，上传到仓库防止代码包被删除 运行时用到自己的项目，不要使用本地代码，而是保证依赖包都是稳定的，防止忘记提交 如果你想发布包把自己写的模板给别人用，记得提交到仓库  这样就可以单个项目独立下来debug了，依赖包版本也管理上了\nPS: go项目就可以使用mod和vendor，如果要集成其他语言代码为子模块可以使用git submodule\n1.3.7 tips #  Q1: 我的包下哪去了？\nA: 依赖的第三方包被下载到了 $GOPATH/pkg/mod 路径下。\nQ2: GO111MODULE 的三个参数 auto 、 on 、 off 有什么区别？\nA: auto 根据是否在 src 下自动判定， on 只用 go.mod ， off 只用 src 。\nQ3: 依赖包中的地址失效了怎么办？比如 golang. org/x/… 下的包都无法下载怎么办？\nA: 在 go.mod 文件里用 replace 替换包，例如\nreplace golang.org/x/text =\u0026gt; github.com/golang/text latest 这样， go 会用 github.com/golang/text 替代 golang.org/x/text\nQ4: 在 go mod 模式中，项目自己引用自己中的某些模块怎么办？\nA: go.mod 文件里的第一行会申明 module main ，把这个 main 改为你的项目名，引用的时候就 import \u0026quot;项目名/模块名\u0026quot; 即可。\n 根据官方的说法，从 Go 1.13 开始，模块管理模式将是 Go 语言开发的默认模式。\n 1.3.8 小结 #  go mod 是未来的默认模式，未来会取消 go path 也就是src 的方式，但自己的项目目录还是尽量按路径放置，不然回头找不到了\n1.3.9 引用 #   Go Modules 掘金\n"},{"id":7,"href":"/1.base/1-4-variables/","title":"1 4 Variables","section":"1.bases","content":"1.4 声明【变量】的各种方式 #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/1.base/1.4-variables\n 讲变量就要先知道 go 语言有哪些数据类型。\n1.4.1 数据类型 #  数据类型的出现是为了把数据分成所需内存大小不同的数据。\n 布尔型(bool): 值只可以是常量 true 或者 false。 数字类型: 整型 int 和浮点型 float，支持复数（业务代码用不到），其中位的运算采用补码。 字符串类型（string）: 使用UTF-8编码标识Unicode文本。 其他：指针、数组、结构体(struct)、联合体 (union不常用)、函数、切片、接口（interface）、Map 、 Channel  大多数类型都是接触过的，比如c++的结构体，比如python的切片，java的接口，别看类型那么多以后写多了自然就会用了。\ngo 语言声明变量的方式非常简单\n1.4.2 第一种方式、var #  var name string 结构为var+变量名+类型\nname = \u0026#34;s\u0026#34; 像这样赋值\n//根据赋值自动判断类型 var p = name 因为name是字符串类型，所以p也是同类型\n//多变量声明,int类型不赋值自动赋值为0，比如d e f var a, b, c = 1, 2, 3 var d, e, f int 一次声明多个类型不同的变量\n//类型不同的多个变量，难看的要死 \tvar ( k int l string ) //这样好看 var m, n, o = \u0026#34;a\u0026#34;, 1, true 1.4.3 方式二、:= #  //直接声明并赋值（必须是初次声明才有冒号） p2 := \u0026#34;as\u0026#34; // 多个变量一次性声明并赋值 h, i, j := 1, 2, 3 1.4.4 常量 #  常量就是不可变的变量，定义方式\nconst identifier [type] = value 约定常量全大写表示\nconst A int = 1 const B = 1 const C, D, E = 1, 1, 1 一般常量被用于枚举\nconst ( Success = 0 UnKonw = 1 Error = 2 ) 不过要枚举还是用 go 自带的特殊常量好一点，这种特殊被认为是可以被编译器修改的常量\n//const 出现时被重置为0，每出现一次自动加1 \tconst ( F = iota G = iota H = iota ) F、G、H 值为0，1，2\n当然可以简写成这样，效果是一样的。\nconst ( I = iota J K ) 1.4.5 类型转换 #  没有什么好说的，和其他语言相似，类型转换都是类型+变量的形式，如下。\nvar aInt int = 17 // 一般用这种方式强制转 \tfmt.Printf(\u0026#34;转float64 %f \\n\u0026#34;, float64(aInt)) fmt.Printf(\u0026#34;转string %v \\n\u0026#34;, strconv.Itoa(aInt)) fmt.Printf(\u0026#34;转float64 %f \\n\u0026#34;, float64(aInt))[] 输出\n转float64 17.000000 转string 17 转float64 17.000000 各种类型转字符串\nresString := fmt.Sprintf(\u0026#34;%d %v %v\u0026#34;, 1, \u0026#34;coding3min\u0026#34;, true) fmt.Println(resString) 输出\n1 coding3min true string 和 bytes 的互相转换\n// string to bytes \tresBytes := []byte(\u0026#34;asdfasdf\u0026#34;) // bytes to string \tresString = string(resBytes) fmt.Println(resString) 输出\nasdfasdf 1.4.6 小结 #  本节介绍了常量和变量，以及变量之间简单类型的转换，这里语言的基础，需要熟练掌握，特别是在做算法的时候更是高频用到。\n"},{"id":8,"href":"/1.base/1-5-switch%E5%92%8Ctypeswitch/","title":"1 5 Switch和typeswitch","section":"1.bases","content":"1.5 switch和type switch #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/1.base/1.5-switch-type-switch\n 1.5.1 if else #   if 20\u0026gt;0{ fmt.Println(\u0026#34;yes\u0026#34;) } 输出\nyes ifelse\n if 20\u0026lt;0{ }else{ fmt.Println(\u0026#34;no\u0026#34;) } 输出\nno 1.5.2 switch 和 type switch #   switch 好理解,是一个替代if else else else接口而提出的,如下，switch 后跟变量，case 后跟常量，只要变量值和常量匹配，就执行该分支下的语句。\nswitch name { case \u0026#34;coding3min\u0026#34;: fmt.Println(\u0026#34;welcome\u0026#34; + name) default: fmt.Println(\u0026#34;403 forbidden:\u0026#34; + name) return } 当然switch语句会逐个匹配case语句，一个一个的判断过去，直到有符合的语句存在。\nswitch { case number \u0026gt;= 90: fmt.Println(\u0026#34;优秀\u0026#34;) case number \u0026gt;= 80: fmt.Println(\u0026#34;良好\u0026#34;) case number \u0026gt;= 60: fmt.Println(\u0026#34;凑合\u0026#34;) default: fmt.Println(\u0026#34;太搓了\u0026#34;) } 如果没有一个是匹配的，就执行default后的语句。\n注意switch后可以跟空，如上\nswitch { 这样case就必须是表达式。\n1.5.3 switch 的高级玩法？ #  有一个流传于坊间的神秘玩法，可以用switch语句来判断传入变量的类型，然后做一些羞羞的事情。x是一个未知类型的变量，switch t := x.(type) 用这个方式来赋值，t就是有确定类型的变量。\nswitch t := x.(type) { case int: return t case float64: return int(math.Ceil(t)) } 什么叫未知类型？？\n这就是 go 中有意思的地方了, interface{} 类型，是一种神奇的类型，他可以是任何类型的接口，而具体的类型是实现。\nvar x interface{} x = 1 fmt.Println(x) 输出1\n所以完整的函数是这样的\nfunc typeSwitchDemo(x interface{}) int { switch t := x.(type) { case int: return t case float64: return int(math.Ceil(t)) } return 0 } 这个东西有什么用呢？？有没有想过如果你有一个场景，你在调用第三方的接口，却发现对方的接口发生了微调，原来的int类型，被转换成了string类型，你必须写出兼容两种方式的代码来解析json。\n那么这个时候，type switch 将会是你的武器。\n感兴趣可以 跑到这里看看，我是怎么使用这个武器的。\nhttps://github.com/golang-minibear2333/golang/blob/master/golang/medium/json_interface/fixed_json.go\n1.5.4 小结 #  通过这一节了解到go语言中无类型语法interface{}，这和java种任何类都是集成于一个统一的基类一样\n"},{"id":9,"href":"/1.base/1-6-for-range/","title":"1 6 for Range","section":"1.bases","content":"1.6 循环 #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/1.base/1.6-for-range\n 今天 go 语言的内容是循环。\n由于在不少实际问题中有许多具有规律性的重复操作，因此在程序中就需要重复执行某些语句。\ngo 语言的循环和其他的没什么不同，只是语法上略微有些差别。\n1.6.1 for 循环方式 1 和 c++、java 相似 #  nums := []int{1, 2, 3, 4, 5, 6} for i := 0; i \u0026lt; len(nums); i++ { fmt.Println(i) } 1.6.2 for 循环方式 2 省略赋值和++ #  a, b := 1, 5 for a \u0026lt; b { fmt.Println(a) a++ } 1.6.3 for 循环方式 3 迭代 #   优点：不用引入无意义的变量 缺点：不是直接索引，如果数据量极大会有性能损耗  for index, value := range nums { fmt.Printf(\u0026#34;key: %v , value: %v \\n\u0026#34;, index, value) } 当然，你可以把方式 3 中 index 去掉,用_忽略掉key\nfor _, v := range nums { fmt.Printf(\u0026#34;value: %v \\n\u0026#34;, v) } 如果你想忽略掉 value，直接用 key也是可以的，这样就消除了迭代方式的缺点！\nfor i := range nums { fmt.Printf(\u0026#34;value: %v \\n\u0026#34;, nums[i]) } 1.6.4 死循环 #  这样就是一个最简单的死循环,循环条件永远为true也是死循环\nfor { } 1.6.5 break、continue #  i := 0 for { fmt.Printf(\u0026#34;死循环测试 %v \\n\u0026#34;, i) i++ if i \u0026gt; 5 { fmt.Println(\u0026#34;满足终止条件，退出\u0026#34;) break //直接跳出循环 \t} if i == 3 { continue //会直接跳过执行后面的语句 \t} fmt.Printf(\u0026#34;死循环测试,第%v次跑到循环结尾\\n\u0026#34;, i) } 输出\n死循环测试 0 死循环测试,第1次跑到循环结尾 死循环测试 1 死循环测试,第2次跑到循环结尾 死循环测试 2 死循环测试 3 死循环测试,第4次跑到循环结尾 死循环测试 4 死循环测试,第5次跑到循环结尾 死循环测试 5 满足终止条件，退出 1.6.6 小结 #  这一节就是全部的循环语法啦\n"},{"id":10,"href":"/1.base/1-7-range%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/","title":"1 7 Range深度解析","section":"1.bases","content":"1.7 range深度解析 #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/1.base/1.7-range-deep\n 1.7.1 range（范围） #  range 关键字在 go 语言中是相当常用好用的语法糖，可以用在 for 循环中迭代 array、slice、map、channel、字符串所有涉及到遍历输出的东西。\n1.7.2 怎么用？ #  我们在前一节 循环 中初次触及到了 range，也知道他可以省略key，或者省略value来循环遍历的特性，但是这种特性要结合实际情况考量该用哪一个。\n切片迭代\nnums := []int{1, 2, 3} for k, v := range nums { fmt.Printf(\u0026#34;key: %v , value: %v \\n\u0026#34;, k, v) } 这和迭代方式非常适合用for-range语句，如果减少赋值，直接索引num[key]可以减少损耗。如下\nfor k, _:= range nums { map迭代 注意，从 Go1开始，遍历的起始节点就是随机了。\nkvs := map[string]string{ \u0026#34;a\u0026#34;:\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;:\u0026#34;b\u0026#34;, } for k, v := range kvs { fmt.Printf(\u0026#34;key: %v , value: %v \\n\u0026#34;, k, v) } 函数中for-range语句中只获取 key 值，然后跟据 key 值获取 value 值，虽然看似减少了一次赋值，但通过 key 值查找 value 值的性能消耗可能高于赋值消耗。\n所以能否优化取决于 map 所存储数据结构特征、结合实际情况进行。\n字符串迭代(一个一个的输出字符)\nfor k,v := range \u0026#34;hello\u0026#34;{ //注意这里单个字符输出的是ASCII码，  //用 %c 代表输出字符 \tfmt.Printf(\u0026#34;key: %v , value: %c \\n\u0026#34;, k, v) } channel （如果不会可以先 mark 下，详细参考后续：go 的并发特性章节）\nch := make(chan int, 10) ch \u0026lt;- 11 ch \u0026lt;- 12 close(ch) // 不用的时候记得关掉,不关掉又没有另一个goroutine存在会死锁哦，可以注释掉这一句体验死锁  for x := range ch { fmt.Println(x) } 结构体\ntmp := []struct{ int string }{ {1, \u0026#34;a\u0026#34;}, {2, \u0026#34;b\u0026#34;}, } for k,v := range tmp{ fmt.Printf(\u0026#34;k:%v, v:%v \\n\u0026#34;,k,v) } 注意：由于循环开始前循环次数就已经确定了，所以循环过程中新添加的元素是没办法遍历到的。\n1.7.3 有可能会遇到的坑！ #  由于range遍历时value是值的拷贝，如果这个时候遍历上一节声明的结构体时，修改value，原结构体不会发生任何变化！\nfor _,v := range tmp{ v.a = 2 } 两次输出一致\nk:0, v:{1 a} k:1, v:{2 b} k:0, v:{1 a} k:1, v:{2 b} 1.7.4 编程 Tips #   遍历过程中可以适情况放弃接收 index 或 value，可以一定程度上提升性能 遍历 channel 时，如果 channel 中没有数据，可能会阻塞 尽量避免遍历过程中修改原数据  1.7.5 小结 #   range可以用于for 循环中迭代 array、slice、map、channel、字符串所有涉及到遍历输出的东西。 for-range 的实现实际上是C风格的for循环 使用index,value接收range返回值会发生一次数据拷贝  "},{"id":11,"href":"/2.func-containers/2-1-func/","title":"2 1 Func","section":"2.func-containers","content":"2.1 函数简单使用和基本知识解析 #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/2.func-containers/2.1-func\n 这里的源码有多个，本节相关的有\n# 函数的简单使用 main.go # 函数当作变量使用，当做 参数传递 function_value.go # 值传递和引用传递 more.go # 递归函数 recursive.go 拓展代码有\n# 函数当作变量使用，当做 参数传递的分页实践 function_value_good_demo.go # 函数方法(go中定义一个类) go_class.go 2.1.1 基本原理 #  函数，几乎是每种编程语言的必备语法，通过函数把一系列的动作汇总起来，在不同的地方重复使用。\n我们在数学中曾经就使用过函数，他的形式类似于y=f（x），这就是一个完整的调用过程，y就是函数计算后得到的值，x就是传入的变量。\n2.1.2 怎么用？ #  相信在看这个教程的人肯定已经接触过其他的编程语言，我就不多废话了，就是干。\n go语言中最基本的函数是这样的，以func为关键字标记函数\nfunc functionParam(num int) { } 当然了，可以有多个形参，类型相同时可以省略，如下\n//多个参数的函数 func functionParams(a, b int, c string) { } 上面说过的函数都没有返回值，一般的函数都有返回值，没有返回值的函数要么是引用传递，可以直接改变参数内容，要么就是用于单元测试或者打印输出等。\n 没有返回值的函数就像一个不完整的男人，只能接受不能输出，来看看这个男人有一个输出的情况。\n返回值标记在函数第一个括号后面，由于go语言是强类型语言，但又和python不同，要写出返回值类型。\n//一个返回值 func funcReturnOne() int { return 1 } 如果说是有多个返回值，要用打括号括起来。\n//多个返回值 func funReturnMany() (int, int) { return 1, 2 } 上面的返回值全部都是匿名的，可以赐他一个名字，函数中不用定义返回值，可以省略几行代码。\n//返回值有名称 func funReturnName() (res int) { //var res int 省掉了 \tres = 1 + 1 return } 用返回就有接收，函数外部用这种方式接收\n//接收多个返回值 \ta, b := funReturnMany() 2.1.3 值传递，引用传递 #  刚刚有说到函数没有返回值的时候，要么是只需要打印结果，要么是只做单元测试，除了这两种情况，没有返回值的函数就是做了很多事情的你没有和老板汇报一样，没有任何意义！\n引用传递和c++类似，先举个值传递的例子。\n//值传递 func noChange(a, b int) { tmp := a a = b b = tmp } 调用打印结果看看\na, b := 1, 2 fmt.Printf(\u0026#34;原值 a:%v,b:%v \\n\u0026#34;, a, b) noChange(a, b) //值传递，并没有修改原值 \tfmt.Printf(\u0026#34;值传递后 a:%v,b:%v \\n\u0026#34;, a, b) 看！像不像任劳任怨的你，忙活半天被老板喜欢的小张抢了功劳。\n原值 a:1,b:2 值传递后 a:1,b:2 下面来看看引用传递的例子。在类型前加一个星号代表该参数是一个指针\n// 引用传递，参数加*号代表指针 func change(a,b *int){ tmp := *a *a = *b *b = tmp } 学过c++再来学go简直是如虎添翼，c++中有一个指针的概念go语言里也有。\n//引用传递，\u0026amp;就是c中的取地址 \tchange(\u0026amp;a,\u0026amp;b) fmt.Printf(\u0026#34;引用传递后 a:%v,b:%v \\n\u0026#34;, a, b) 输出结果，可以看到值被调换了。引用传递需要加\u0026amp;符号，术语叫取地址。函数里的对他做的任何操作都会改变原来的变量内容。\n引用传递后 a:2,b:1 上面的例子传入的是指针，还有一种叫引用类型，和指针的区别是不需要星号和\u0026amp;，对他的修改会直接改动到原有变量的值。\nps:go语言中只有三种引用类型，slice(切片)、map(字典)、channel(管道)\n2.1.4 函数进阶 #  上面说的东西都很简单了，基本学过任何一门语言的人都能瞬间看懂，和python、c++、javascript一样，go中也有把函数打作参数传递的语法。\n像这样，functionValue函数的形参里有一个名为do的函数，需要提前指定do函数有什么参数和返回值。\nfunc functionValue(a, b int, do func(int, int) int) { fmt.Println(do(a, b)) } 然后do(a,b)是在functionValue内部调用的。这种特性有什么用呢？定义两个参数为int，返回为int的函数。\nfunc add(a, b int) int { return a + b } func sub(a, b int) int { return a - b } 因为规则符合do函数的规则，两个都可以传递过去，看！这就不用修改函数内部而出现了两种效果。\nfunctionValue(1, 1, add) functionValue(1, 1, sub) 在设计模式里，这种方式叫装饰器模式（Decorator Pattern）:允许向一个现有的对象添加新的功能，同时又不改变其结构。\n 当然，你也不必每次传递函数的时候都憨厚老实的定义一个新函数，因为有时候你定义的函数就只会在这里用到，只不过是把实现放在调用外部，而不修改原函数代码罢了。\n//匿名函数 \tfunctionValue(1, 1, func(i1 int, i2 int) int { return i1 * i2 }) 上面这个例子多看几遍啊！！\n2.1.5 实际的使用 #  你可以参考函数测速例子\n定义一个测速函数。\nfunc speedTime(handler func() (string), funcName string) { t := time.Now() handler() elapsed := time.Since(t) fmt.Println(funcName+\u0026#34;spend time:\u0026#34;, elapsed) } 传入不同的函数都可以测速度。\nspeedTime(appendStr, \u0026#34;appendStr\u0026#34;) speedTime(appendStrQuick, \u0026#34;appendStrQuick\u0026#34;) 小Tips：\n 还有你可以传filter函数做过滤，mapping做映射等实际的用法 有时候也可以作为排序递增，递减的依据  2.1.6 小结 #  本节讲述了Go中函数的基本语法，包括定义、多值返回，函数的值传递和引用传递，还可以当变量来用，可以把函数当参数来传递\n"},{"id":12,"href":"/2.func-containers/2-2-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/","title":"2 2 匿名函数和闭包","section":"2.func-containers","content":"2.2 匿名函数和闭包 #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/2.func-containers/2.2-no-name-func\n 与本节相关的有，匿名函数没有留源代码\n2.2.1 匿名函数 #  话不多说，今天小熊就带各位家人感受下go语言函数中的高级语法。\n在 前面的文章 里我们学会了把函数当作变量传递，可以在不改动原有函数内部实现的情况下，改变函数实现细节（设计模式：装饰器）。\n这种情况下的作为变量传递的函数往往只有这一个地方用到了，其他地方不会重复使用。那就没必要单独定义一个函数在外面！（多此一举的事本熊不做！）\nlike this:\nfunc functionValue(a, b int, do func(int, int) int) { fmt.Println(do(a, b)) } //使用匿名函数的方法调用他 实现匿名加函数 functionValue(1,2,func(a,b int) int{ return a+b }) //使用匿名函数的方法调用他 实现匿名减函数 functionValue(1,2,func(a,b int) int{ return a-b }) 输出\n3 -1 在调用的时候我们才实现了一个匿名函数（没有名字的函数）\n那是不是只有把函数当变量传递的时候才用到匿名函数呢？并，不，是！\n各位同学，让我上黑板给大家实现一个简单的匿名函数用法。\nf := func(i int) { fmt.Println(i) } f(1) 把匿名函数赋值给一个变量(这里是f)，f就是他的函数名，后面就可以直接调用啦~，但是这种简单使用的情况实际上会不会用到呢？很残酷，几乎没有。\n匿名函数配合下面的场景使用效果更佳。\n2.2.2 闭包 #  你有没有一种情况，常常要定义好多全局变量来共享数据，这种变量一旦多了非常难看，还会污染环境，有没有一种办法，可以通过重复调用同一个函数，来修改函数内部的变量呢？\n我翻来覆去发现是真的有！这个东西就叫闭包！\n 闭包的简单实现，把函数定义在函数内部，并当作返回值返回。\nfunc closureSample() func() { count := 0 return func() { count ++ fmt.Printf(\u0026#34;调用次数 %v \\n\u0026#34;, count) } } 怎么用才爽？我先丧心病狂的调用两次closureSample函数，得到两个函数c1、c2,这两个函数就是closureSample函数的返回值，类型是一个匿名函数。\nc1, c2 := closureSample(), closureSample() 疯狂调用！！！\n c1() c1() c1() // 你会发现c2又从1开始输出，因为两个函数的变量是独立使用的 \tc2() c2() 输出\n调用次数 1 调用次数 2 调用次数 3 调用次数 1 调用次数 2 调用次数 3 神奇不神奇！在调用c2的时候，完全没有影响到c1！\n这是因为各个函数是独立使用一套自己的内部变量，互相不影响，所以闭包也可以当测试用例使用。\n用来传入不同的实现，重复调用得到不同的返回，不用定义全局变量。\n 好处：可以减少全局变量防止变量污染 坏处：延长了局部变量和函数的生命周期，增加了 gc 的压力  2.2.3 闭包形式 2 #  通过上面的例子，不难发现闭包内部的匿名函数可以使用到外部的变量。\n闭包形式 2，立即执行函数，声明完以后加括号，用以表示即刻调用。\nfunc() { // to do something \t}() 2.2.4 闭包存在的 bug #  go 里创建一个协程(类似于子线程)非常的容易，只要在语句前加一个go关键字就可以了。看看下面这个函数会出现什么问题。\nfor i := 0; i \u0026lt; 3; i++ { fmt.Printf(\u0026#34;第一次 i 产生变化中 %v \\n\u0026#34;, i) go func() { fmt.Printf(\u0026#34;第一次输出： %v\\n\u0026#34;, i) }() } time.Sleep(time.Second) 协程创建完以后立即会执行，但是协程创建这个事件和协程执行代码是分离的，他可以全部创建完再执行，而且主线程和协程是同时运行的(并发)，有可能主线程执行完了，协程还没执行。\n这个时候协程才会调用外部的变量，i 已经变成 3 了。\n第一次 i 产生变化中 0 第一次 i 产生变化中 1 第一次 i 产生变化中 2 第一次输出： 3 第一次输出： 3 第一次输出： 3 解决办法，创建副本，可以给匿名函数加一个参数，传值过来自动生成副本\nfor i := 0; i \u0026lt; 3; i++ { fmt.Printf(\u0026#34;第二次 i 产生变化中 %v \\n\u0026#34;, i) go func(tmp int) { fmt.Printf(\u0026#34;第二次输出： %v\\n\u0026#34;, tmp) }(i) } time.Sleep(time.Second) 输出\n第二次 i 产生变化中 0 第二次 i 产生变化中 1 第二次输出： 0 第二次 i 产生变化中 2 第二次输出： 2 第二次输出： 1 第二种创建副本的形式\nfor i := 0; i \u0026lt; 3; i++ { fmt.Printf(\u0026#34;第三次 i 产生变化中 %v \\n\u0026#34;, i) tmp := i go func() { fmt.Printf(\u0026#34;第三次输出： %v\\n\u0026#34;, tmp) }() } time.Sleep(time.Second) 输出\n第三次 i 产生变化中 0 第三次 i 产生变化中 1 第三次 i 产生变化中 2 第三次输出： 0 第三次输出： 2 第三次输出： 1 2.2.5 小结 #  匿名函数在做参数传递时常用于设计模式中的订阅模式和策略模式、装饰器模式、调用链模式，同时匿名函数可以访问到外部变量的特性，也常常用于并发，在用于并发时要小心闭包bug。\n"},{"id":13,"href":"/2.func-containers/2-3-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/","title":"2 3 可变参数","section":"2.func-containers","content":"2.3 可变参数 #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/2.func-containers/2.3-varargs\n 接连两篇函数专题深度解析，相信大家已经对函数的语法有了深入的了解。\n这次小熊给大家带来了一个函数的特性【可变参数】，作为函数专题的结束。\n2.3.1 有没有发现？ #  我们有时候会用到的输出、错误输出、字符串格式化系统函数，你可以传入任意个数的参数，他全都能处理！\nfmt.Println(\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;) 就像一个任劳任怨的老父亲，那到底是为什么呢？\n2.3.2 因为 #  因为在go语言中语言级别自带了一种语法，可以声明可变参数！\nfunc 函数名(固定参数，v ...T) (返回参数列表){ 函数体 } 2.3.3 怎么用？ #  先和小熊一起试试，写一个不定参数累加的函数\nfunc sum(t ...int) (res int) { for _, v := range t { res += v } return res } fmt.Println(sum(1, 2, 3, 4, 5)) 输出结果\n15 2.3.4 如果连参数类型都不知道，怎么办？ #  上一节我们已知参数类型是int，还记得我们前面说过的switch判断类型做处理的例子吗？ switch和type switch。\n参考这个例子重写下函数，让他可以接收任意类型的参数。\nfunc sumNum(t ...interface{}) (res float64){ for _,tmp := range t{ switch v :=tmp.(type) { case int: res += float64(v) case float64: res+= v case float32: res += float64(v) } } return res } 测试下\nfmt.Println(sumNum(1,2.1,\u0026#34;asd\u0026#34;,true)) 因为忽略了输出\n3.1 但是上面的例子并没有覆盖全部的数字，如果一个一个类型的匹配会疯掉的。有没有更好的方法，可以一下子匹配到所有的数字？\nfunc sumNum(t ...interface{}) (res float64) { for _, tmp := range t { switch v := tmp.(type) { case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64, float32, float64, complex64, complex128: convertStr := fmt.Sprintf(\u0026#34;%v\u0026#34;, v) convertFloat64, _ := strconv.ParseFloat(convertStr, 64) res += convertFloat64 } } return res } 上面的代码在case里一下子匹配了所有可能的数字类型，再用格式化输出转换成字符串，最后转换成float64来使用，这是一种折中的办法，速度可能会比较慢（因为格式化内部逻辑比较复杂消耗速度）。\n为了保证速度还是不要省掉一大堆的case，明确了类型再做强转。\n2.3.5 留给你的寻找的答案 #  有没有一种只留一个case，同时处理速度又快的方法呢？\n—— 爱你们的小熊\n2.3.6 小结 #  本节介绍了不定参数，知道参数类型与不知道参数类型的处理方法，你可以把这种模式用于类型转换、以及策略模式。\n在fmt包中，有很多Print就是使用了不定参数，有兴趣可以看一下源码。\n"},{"id":14,"href":"/2.func-containers/2-4-map/","title":"2 4 Map","section":"2.func-containers","content":"2.4 map #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/2.func-containers/2.4-map\n 2.4.1 映射关系容器 map #  Go语言提供的映射关系容器为 map ， map 使用散列表hash实现。查找复杂度为O(1)，和数组一样，最坏的情况下为O(n),n为元素总数。\n这就是Go中map的定义格式。\nmap[keyType] valueType 注意了，map 是一种引用类型，初值是nil,定义时必须用make来创建，否则会报错\npanic: assignment to entry in nil map 必须要申请空间，所有的引用类型都要这么做\nvar m map[string]string m = make(map[string]string) 当然，也可以这么写\nm := make(map[string]string) 2.4.2 使用 #  赋值\nm[\u0026#34;name\u0026#34;] = \u0026#34;coding3min\u0026#34; m[\u0026#34;sex\u0026#34;] = \u0026#34;man\u0026#34; 循环遍历\nfor key := range m { // 原来不用Printf也可以完成拼接输出啊！ \tfmt.Println(\u0026#34;key:\u0026#34;, key, \u0026#34;,value:\u0026#34;, m[key]) } 删除集合元素\ndelete(m, \u0026#34;name\u0026#34;) PS: 在取值的时候m[key]，假如key不存在，不会报错，会返回value类型的默认值，比如int类型默认值为0\n当然了，如果你想明确的知道元素是否存在，如下：\nif value, ok := m[key]; ok { fmt.Println(key, \u0026#34;存在，值为：\u0026#34;, value) } else { fmt.Println(key, \u0026#34; 不存在\u0026#34;) } map容器就到这里了。\n2.4.3 能够在并发环境中使用的map #  Go中的map在并发读的时候没问题，但是并发写就不行了（线程不安全），会发生竞态问题。\n所以有一个叫sync.Map的封装数据结构供大家使用，简单用法如下： 定义和存储\nvar scene sync.Map scene.Store(\u0026#34;name\u0026#34;, \u0026#34;coding3min\u0026#34;) scene.Store(\u0026#34;age\u0026#34;, 11) 取值\nv, ok := scene.Load(\u0026#34;name\u0026#34;) if ok { fmt.Println(v) } v, ok = scene.Load(\u0026#34;age\u0026#34;) if ok { fmt.Println(v) } 输出\ncoding3min 11 删除和遍历,这里遍历就用到了 函数当作参数传递 和 匿名函数 的知识。\nscene.Delete(\u0026#34;age\u0026#34;) scene.Range(func(key, value interface{}) bool { fmt.Println(\u0026#34;key:\u0026#34;,key,\u0026#34;,value:\u0026#34;,value) return true }) 2.4.4 小结 #  本节介绍了字典map类型，这种类型在很多语言中都有，并且学习了它的增加删除元素的方法。\n还介绍了并发环境下使用的线程安全的 sync.Map。\n"},{"id":15,"href":"/2.func-containers/2-5-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/","title":"2 5 数组和切片","section":"2.func-containers","content":"2.5 数组和切片 #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/2.func-containers/2.5-arrray https://github.com/golang-minibear2333/golang/blob/master/2.func-containers/2.5-slice\n 2.5.1 Golang中的数组 #  其实在 循环 那一节用到过数组，我快速介绍一下。\n 数组中是固定长度的连续空间（内存区域） 数组中所有元素的类型是一样的  var a1 [10]int //初始化数组 \tvar b1 = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0} 多维数组\n//声明二维数组，只要 任意加中括号，可以声明更多维，相应占用空间指数上指 \tvar arr [3][3]int //赋值 \tarr = [3][3]int{ {1, 2, 3}, {2, 3, 4}, {3, 4, 5}, } 2.5.2 何谓切片？ #  类比c语言，一个int型数组int a[10],a的类型是int*，也就是整型指针，而c语言中可以使用malloc()动态的分配一段内存区域，c++中可以用new()函数。例如：\nint* a = (int *)malloc(10); int* b = new int(4); 此时，a和b的类型也是int*，a和b此时分配内存的方式类似于go语言中的切片。\nGo的数组和切片都是从c语言中延续过来的设计。\n2.5.3 有何不同？ #  var sliceTmp []int 可以看到和c不同的是，go可以声明一个空切片（默认值为nil），然后再增加值的过程中动态的改变切片值大小。\n2.5.4 怎么动态增加？ #  增加的方式只有一种，使用append函数追加。\nsliceTmp = append(sliceTmp, 4) sliceTmp = append(sliceTmp, 5) 每个切片有长度len和容量cap两个概念，长度是我们最熟知的，和数组长度相同，可以直接用来遍历。\nfor _,v := range slice1{ fmt.Println(v) } 用切糕来对比\n 每个切片，在声明或扩建时会分配一段连续的空间，称为容量cap，是不可见的；真正在使用的只有一部分连续的空间，称为长度len，是可见的。\n每次append时，如果发现cap已经不足以给len使用，就会重新分配原cap两倍的容量，把原切片里已有内容全部迁移过去。\n新分配的空间也是连续的，不过不一定直接在原切片内存地址处扩容，也有可能是新的内存地址。\n2.5.5 切片的长度与容量，len cap append copy #  slice1 := []int{1, 2, 3} 普通切片的声明方式，长度和容量是一致的。\nlen=3 cap=3 slice=[1 2 3] 当然，控制权在我们手上,我们可以自己控制长度和容量，\nslice1 = make([]int, 3, 5) // 3 是长度 5 是容量 输出\nlen=3 cap=5 slice=[0 0 0] 尝试使用一般的方式扩容\nslice1[len(slice1)] = 4 //报错 panic: runtime error: //index out of range [3] with length 3 这种方式是会报错的，虽然容量是 5 ，但是数组长度是3，这里是以长度为准，而不是容量，append内部如果超过容量相当于创建了一个新数组，每个新数组都是定长的，只不过外部是切片。\n尝试扩容\nslice1 = append(slice1, 4) 输出，可以发现len扩容了！\nlen=4 cap=5 slice=[0 0 0 4] 让我们连续扩容，让容量超过5\nslice1 = append(slice1, 5) slice1 = append(slice1, 6) // 到这里长度超过了容量，容量自动翻倍为 5*2 输出\nlen=6 cap=10 slice=[0 0 0 4 5 6] 上面的过程，我 用自己的代码模拟一遍\n// 上面容量自动翻倍的过程可以看作和下面一致 \tslice1 = make([]int, 3, 5) // 3 是长度 5 是容量 \tslice1 = append(slice1, 4) slice1 = append(slice1, 5) // 长度不变，容量自动翻倍为 5*2 \tslice2 := make([]int, len(slice1), (cap(slice1))*2) // 拷贝 slice1 的内容到 slice2  // 注意是后面的拷贝给前面 \tcopy(slice2, slice1) slice2 = append(slice2, 6) 你理解容量，长度的概念了吗？\n2.5.6 切片的复制 #  切片的复制，回顾一下，我们原来是用copy函数\nslice2 := make([]int, len(slice1), cap(slice1)) /* 拷贝 slice1 的内容到 slice2 */ copy(slice2, slice1) // 注意是后面的拷贝给前面 切片还有一种方式复制方式，比较快速\nslice3 := slice2[:] 但是有一种致命的缺点，这是浅拷贝，slice3和slice2是同一个切片，无论改动哪个，另一个都会产生变化。\n2.5.7 截取部分元素 #  切片之所以为切片，就是可以把部分元素截取出来\nslice2的值是[0 0 0 4 5 6]，现在有一个需求，要截取第2个元素出来\nslice3 := slice2[0:1] 输出\nlen=1 cap=10 slice=[0] 我们分别修改slice3和slice2\nslice3[0] = 1 slice2[0] = 2 printSlice(slice2) printSlice(slice3) 发现输出\nlen=6 cap=10 slice=[2 0 0 4 5 6] len=1 cap=10 slice=[2] 说明，截取出现的元素依然是同一块内存（切片是引用类型的）。\n所以截取部分元素之后，还是得用copy来复制一遍，如下。\nslice2 = []int{0, 0, 0, 1, 2, 3} slice3 = make([]int, 1, 1) copy(slice3, slice2[0:1]) 2.5.8 工具函数补充 #  排序工具函数\nslice2 = []int{0, 3, 0, 1, 2, 0} sort.Ints(slice2) fmt.Println(slice2) 输出\n[0 0 0 1 2 3] 其他知识参考 排序用户自定义数据集\n2.5.9 小结 #  本节介绍了切片与数组的区别，动态增加，容量和长度的概念，以及len cap append copy 函数的使用，还介绍了切片的复制和截取。\n"},{"id":16,"href":"/3.grammar-advancement/3-1-point/","title":"3 1 Point","section":"3.grammar-advancements","content":"3.1 指针讨论 #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/3.grammar-advancement/3.1-point\n 3.1.1 指针 #  c 中有指针的概念，在 go 中也有，但是实际上用的比较少，因为指针容易出错，而且不易阅读。\n每个变量都有他的地址\nvar a int fmt.Printf(\u0026#34;a 的地址是：%p \\n\u0026#34;, \u0026amp;a) 输出\na 的地址是：0xc0000b2008 指针用来存地址\n//声明 变量名 + 指针类型 , 命令规则以ptr结尾 var ptr *int /* 指向整型*/ // var fp *float32 /* 指向浮点型 */ ptr = \u0026amp;a // 变量内部存的值是普通类型，指针内部存的值是地址 fmt.Printf(\u0026#34;ptr 存的值是：%p \\n\u0026#34;, ptr) 输出，可以看到 ptr 存的值就是 a 的地址。\nptr 存的值是：0xc0000b2008 存的就是 a 的地址，ptr 的指向*ptr 肯定就是 a 本身了。\nif a == *ptr { fmt.Println(\u0026#34;a == *ptr\u0026#34;) } 输出\na == *ptr 3.1.2 指针的作用 #  指针可以消灭掉返回值，直接对参数做改变。\n定义一个交换函数，形参为指针类型\nfunc swap(x *int, y *int) { var temp int temp = *x /* 保存 x 地址的值 */ *x = *y /* 将 y 赋值给 x */ *y = temp /* 将 temp 赋值给 y */ } 调用\na := 100 b := 200 //操作地址，不需要返回 swap(\u0026amp;a, \u0026amp;b) fmt.Printf(\u0026#34;交换后 a 的值 : %d\\n\u0026#34;, a) fmt.Printf(\u0026#34;交换后 b 的值 : %d\\n\u0026#34;, b) 输出\n交换后 a 的值 : 200 交换后 b 的值 : 100 虽然可以这么做，但是不推荐，因为 go 比 c++ 多出来多返回值的特性，所以这里写在返回里可读性更强。\nPS1: 但如果你的参数是比较复杂的类型，比如数组。用指针可以节省空间。\nPS2: 对引用类型的操作会改变原引用类型的值，这里与指针有异曲同工之妙。\n3.1.3 多维指针 #  刚刚用到的指针，只不过指向一个变量的地址，他就被叫做一维指针。\nvar ptr *int ptr = \u0026amp;a 指针本身也是一个变量，是变量就有地址，所以指针也可以被取地址。\nvar ptr *int pptr = \u0026amp;ptr *int 类型的指针存的是 int 类型数据的地址，得到 *变量类型 就是他的指针，推导出指向 *int 变量的指针为 **int 类型，这种类型被称为二维指针，每多一个 * 就多一个维。\nvar a int var ptr *int //一维 var pptr **int // 二维 var ppptr ***int // 三维  ptr = \u0026amp;a pptr = \u0026amp;ptr ppptr = \u0026amp;pptr fmt.Printf(\u0026#34;a的地址：%p \\n\u0026#34;, \u0026amp;a) fmt.Printf(\u0026#34;ptr存的地址：%p \\n\u0026#34;, ptr) fmt.Printf(\u0026#34;pptr存的地址的指向：%p \\n\u0026#34;, *pptr) fmt.Printf(\u0026#34;ppptr存的地址的指向的指向：%p \\n\u0026#34;, **ppptr) 输出\na的地址：0xc000014090 ptr存的地址：0xc000014090 pptr存的地址的指向：0xc000014090 ppptr存的地址的指向的指向：0xc000014090 PS1: 日常工作中，不建议使用多维指针，可读性不好，容易犯错误，一层指针能搞定的，一定不要使用多维炫技术。不然过几个月你自己都看不懂。\nPS2: 不得不使用二维指针的场景：你希望在一个函数的参数中改变一个指针的值，你就只能传这个指针的指针给这个函数。\nPS3：多维指针的唯一好处：减少传参\n你在工作中啥时候用到了指针/多维指针？\n3.1.4 小结 #  在Java中没有指针的概念，但是有引用的概念，在C++中比较常见，我们操作内存一定会用到指针，存储了变量的地址。\n为了程序的可读性，一般只会用到一维指针，掌握指针的概念，后面还有大用。\n"},{"id":17,"href":"/3.grammar-advancement/3-2-struct/","title":"3 2 Struct","section":"3.grammar-advancements","content":"3.2 结构体 #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/3.grammar-advancement/3.2-struct\n 3.2.1 go 语言中的结构体 #  和 c++ 的结构体类似，如下定义一个结构体类型。\ntype Body struct { name string age int } 像这样就可以使用\nvar body Body body.name = \u0026#34;coding3min\u0026#34; body.age = 12 fmt.Println(body) 输出\n{coding3min 12} 3.2.2 go 中的类 #  结构体在 go 中是最常用的一种语法，有没有想过为什么？\n这是因为我们学过一些面向对象的语言，其中有一个叫类的概念，但是 go 里面没有。\ngo 用一种特殊的方式，把结构体本身看作一个类。\n一个成熟的类，具备成员变量和成员函数，结构体本身就有成员变量，再给他绑定上成员函数，是不是就可以了！\ntype people struct { name string } func (p people) toString() { fmt.Println(p.name) fmt.Printf(\u0026#34;p的地址 %p \\n\u0026#34;, \u0026amp;p) } 上面给 people 结构体绑定了一个函数, 调用下看看\np1 := people{\u0026#34;coding3min\u0026#34;} p1.toString() 按照 toString() 方法的内容，先输出 name 再输出 p的地址\ncoding3min p的地址 0xc0001021f0 #这里的地址一会有用 再绑定一个函数，你想想和上面的函数有什么区别，注意 60% 的人第一眼都没看出来\nfunc (p *people) sayHello() { fmt.Printf(\u0026#34;Hello! %v \\n\u0026#34;, p.name) fmt.Printf(\u0026#34;*p的地址 %p \\n\u0026#34;, p) } 可以注意到，和 toString() 函数不同的是， sayHello() 用了指针的方式进行绑定。\n输出，可以注意到这里的地址和上面的不同。\nHello! coding3min *p的地址 0xc00008e1e0 这两种绑定方式，都是相当于给结构体绑定了函数，这个结构体等价于对象，唯一的不同点就是如果使用 * 绑定函数，那么这种对象就是单例的，引用的是同一个结构体。\np1 := people{\u0026#34;coding3min\u0026#34;} p1.sayHello() p2 := \u0026amp;people{\u0026#34;tom\u0026#34;} p2.sayHello() 输出，可以看到地址一致。\n*p的地址 0xc00008e220 p2的地址 0xc00008e220 3.2.3 一些拓展的结构体知识 #  声明时赋值\nbody2 := Body{ \u0026#34;tom\u0026#34;, 13, } 结构体数组\nbodys := []Body{ Body{\u0026#34;jack\u0026#34;, 12}, Body{\u0026#34;lynn\u0026#34;, 18}, } 匿名结构体，一般用来存测试用例\nclass1 := struct { bodys []Body }{ []Body{Body{\u0026#34;jerry\u0026#34;, 24}}, } 3.2.4 小结 #  通过这篇文章，你应该对 go 语言中的 对象 有一个直观的体验。\n 学会如何给结构体绑定方法 了解绑定方法时是否加 * 号（指针）的区别 学会声明时赋值、结构体数组、匿名结构体的知识  我们在 java 里学习过 interface （接口），通过接口定义一系列的函数（标准），实现接口的对象需要实现所有的方法，那 go 语言中是否有这种语法呢？我们下次再见！\n"},{"id":18,"href":"/3.grammar-advancement/3-3-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%A4%9A%E6%80%81/","title":"3 3 接口与多态","section":"3.grammar-advancements","content":"3.3 接口与多态 #  今天和大家聊聊 golang 的接口（ interface ）\n 本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/3.grammar-advancement/3.3-interface\n 3.3.1 接口 #  接口同 java 一样，可以把一堆有共性的方法定义在里面，但是比 java 灵活的是，不需要显式实现接口，你可以自己控制实现哪些方法。\n不需要显式实现的意思是，不需要像 java 那样 implements interface 写出来，别急，看完下面的例子就知道了。\n定义一个接口。\ntype humanInterface interface { eat() string play() string } 定义一个结构体（类）\ntype man struct { name string } 实现接口，语法和 给结构体添加方法 一样，完全看不出来 接口 的身影。\nfunc (p man) eat() string { return \u0026#34;eat banana\u0026#34; } func (p man) play() string { return \u0026#34;play game\u0026#34; } 上面的代码给结构体添加了和接口一样的方法，只要完全实现接口中的方式，默认这就实现接口（隐式）。\n用下面这样的格式，把结构体赋值给接口来实现他 接口实例 = new(类型)\nvar human humanInterface human = new(man) fmt.Println(human.eat()) fmt.Println(human.play()) 输出\neat banana play game PS: new 关键字和 c++ 中的不同，释放内存由 go 的垃圾处理机来做，不需要自己释放内存。\n3.3.2 这不是接口 #  上面的是一个很简单实现接口的例子。 要注意的是，必须实现了所有接口的方法才算是实现了这个接口。\n假如我们只实现了接口中的一个方法，会发生什么事？\ntype dogInterface interface { eat() string play() string } type dog1 struct { name string } func (d dog1) eat() string { return \u0026#34;Eat dog food\u0026#34; } var dog dogInterface dog = new(dog1) 报错\n报错：Cannot use 'new(dog1)' (type *dog1) as type dogInterface in assignment Type does not implement 'dogInterface' as some methods are missing: play() string more... 3.3.3 多态 #  当然，多态是面向对象的灵魂， go 怎么能没有？\n这是一个以接口为参数的函数，方法内调用了接口中方法。\nfunc humanDoWhat(p humanInterface) { fmt.Println(p.eat()) fmt.Println(p.play()) } 传入不同的类（结构体）\nw := woman{\u0026#34;lisa\u0026#34;} m := man{\u0026#34;coding3min\u0026#34;} // 多态的含义就是不需要修改函数，只需要修改外部实现 // 同一个接口有不同的表现 humanDoWhat(w) humanDoWhat(m) 不同输出\nlisaeat rice lisawatch TV coding3mineat banana coding3minplay game java 中的多态有三个必要条件\n 继承 重写 父类引用指向子类对象  但是 go 没有继承、重写， go 作为一种优雅的语言， 给我们提供了这种解决方案，那就是鸭子类型：看起来 像鸭子， 那么它就是 鸭子！\n3.3.4 练习 #   练习题目-practice.go\n3.3.5 小结 #  interface 在go中是一种神奇的存在，interface{} 可以代表所有类型的基类，interface 也可以定义为类的方法模板，只不过在Go中是隐式的实现。\n这是一种很奇妙的体验，以后在工作或实战中很快就会熟悉了。\n"},{"id":19,"href":"/3.grammar-advancement/3-4-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","title":"3 4 异常处理","section":"3.grammar-advancements","content":"3.4 异常处理 #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/3.grammar-advancement/3.4-errors\n 3.4.1 异常处理思想 #  在 go 语言里是没有 try catch 的概念的，因为 try catch 会消耗更多资源，而且不管从 try 里面哪个地方跳出来，都是对代码正常结构的一种破坏。\n所以 go 语言的设计思想中主张\n 如果一个函数可能出现异常，那么应该把异常作为返回值，没有异常就返回 nil 每次调用可能出现异常的函数时，都应该主动进行检查，并做出反应，这种 if 语句术语叫卫述语句  所以异常应该总是掌握在我们的手上，保证每次操作产生的影响达到最小，保证程序即使部分地方出现问题，也不会影响整个程序的运行，及时的处理异常，这样就可以减轻上层处理异常的压力。\n同时也不要让未知的异常使你的程序崩溃。\n3.4.2 异常的形式 #  我们应该让异常以这样的形式出现\nfunc Demo() (int, error) 我们应该让异常以这样的形式处理（卫述语句）\n_,err := errorDemo() if err!=nil{ fmt.Println(err) return } 3.4.3 自定义异常 #  比如程序有一个功能为除法的函数，除数不能为 0 ，否则程序为出现异常，我们就要提前判断除数，如果为 0 返回一个异常。那他应该这么写。\nfunc divisionInt(a, b int) (int, error) { if b == 0 { return -1, errors.New(\u0026#34;除数不能为0\u0026#34;) } return a / b, nil } 这个函数应该被这么调用\na, b := 4, 0 res, err := divisionInt(a, b) if err != nil { fmt.Println(err.Error()) return } fmt.Println(a, \u0026#34;除以\u0026#34;, b, \u0026#34;的结果是 \u0026#34;, res) 可以注意到上面的两个知识点\n 创建一个异常 errors.New(\u0026quot;字符串\u0026quot;) 打印异常信息 err.Error()  只要记得这些，你就掌握了自定义异常的基本方法。\n但是 errors.New(\u0026quot;字符串\u0026quot;) 的形式我不建议使用，因为他不支持字符串格式化功能，所以我一般使用 fmt.Errorf 来做这样的事情。\nerr = fmt.Errorf(\u0026#34;产生了一个 %v 异常\u0026#34;, \u0026#34;喝太多\u0026#34;) 3.4.4 详细的异常信息 #  上面的异常信息只是简单的返回了一个字符串而已，想在报错的时候保留现场，得到更多的异常内容怎么办呢？这就要看看 errors 的内部实现了。其实相当简单。\nerrors 实现了一个叫 error 的接口，这个接口里就一个 Error 方法且返回一个 string ，如下\ntype error interface { Error() string } 只要结构体实现了这个方法就行，源码的实现方式如下\ntype errorString struct { s string } func (e *errorString) Error() string { return e.s } // 多一个函数当作构造函数 func New(text string) error { return \u0026amp;errorString{text} } 所以我们只要扩充下自定义 error 的结构体字段就行了。\n这个自定义异常可以在报错的时候存储一些信息，供外部程序使用\ntype FileError struct { Op string Name string Path string } // 初始化函数 func NewFileError(op string, name string, path string) *FileError { return \u0026amp;FileError{Op: op, Name: name, Path: path} } // 实现接口 func (f *FileError) Error() string { return fmt.Sprintf(\u0026#34;路径为 %v 的文件 %v，在 %v 操作时出错\u0026#34;, f.Path, f.Name, f.Op) } 调用\nf := NewFileError(\u0026#34;读\u0026#34;, \u0026#34;README.md\u0026#34;, \u0026#34;/home/how_to_code/README.md\u0026#34;) fmt.Println(f.Error()) 输出\n路径为 /home/how_to_code/README.md 的文件 README.md，在 读 操作时出错 3.4.5 defer #  上面说的内容很简单，在工作里也是最常用的，下面说一些拓展知识。\nGo 中有一种延迟调用语句叫 defer 语句，它在函数返回时才会被调用，如果有多个 defer 语句那么它会被逆序执行。\n比如下面的例子是在一个函数内的三条语句，他是这么怎么执行的呢？\ndefer fmt.Println(\u0026#34;see you next time!\u0026#34;) defer fmt.Println(\u0026#34;close all connect\u0026#34;) fmt.Println(\u0026#34;hei boy\u0026#34;) 输出如下, 可以看到两个 defer 在程序的最后才执行，而且是逆序。\nhei boy close all connect see you next time! 这一节叫异常处理详解，终归是围绕异常处理来讲述知识点， defer 延迟调用语句的用处是在程序执行结束，甚至是崩溃后，仍然会被调用的语句，通常会用来执行一些告别操作，比如关闭连接，释放资源（类似于 c++ 中的析构函数）等操作。\n涉及到 defer 的操作\n 并发时释放共享资源锁 延迟释放文件句柄 延迟关闭 tcp 连接 延迟关闭数据库连接  这些操作也是非常容易被人忘记的操作，为了保证不会忘记，建议在函数的一开始就放置 defer 语句。\n3.4.6 panic #  刚刚有说到 defer 是崩溃后，仍然会被调用的语句，那程序在什么情况下会崩溃呢？\nGo 的类型系统会在编译时捕获很多异常，但有些异常只能在运行时检查，如数组访问越界、空指针引用等。这些运行时异常会引起 painc 异常（程序直接崩溃退出）。然后在退出的时候调用当前 goroutine 的 defer 延迟调用语句。\n有时候在程序运行缺乏必要的资源的时候应该手动触发宕机（比如配置文件解析出错、依赖某种独有库但该操作系统没有的时候）\ndefer fmt.Println(\u0026#34;关闭文件句柄\u0026#34;) panic(\u0026#34;人工创建的运行时异常\u0026#34;) 报错如下\n 3.4.7 panic recover #  出现 panic 以后程序会终止运行，所以我们应该在测试阶段发现这些问题，然后进行规避，但是如果在程序中产生不可预料的异常（比如在线的web或者rpc服务一般框架层），即使出现问题（一般是遇到不可预料的异常数据）也不应该直接崩溃，应该打印异常日志，关闭资源，跳过异常数据部分，然后继续运行下去，不然线上容易出现大面积血崩。\n然后再借助运维监控系统对日志的监控，发送告警给运维、开发人员，进行紧急修复。\n语法如下：\nfunc divisionIntRecover(a, b int) (ret int) { defer func() { if err := recover(); err != nil { // 打印异常，关闭资源，退出此函数 \tfmt.Println(err) ret = -1 } }() return a / b } 调用\nvar res int datas := []struct { a int b int }{ {2, 0}, {2, 2}, } for _, v := range datas { if res = divisionIntRecover(v.a, v.b); res == -1 { continue } fmt.Println(v.a, \u0026#34;/\u0026#34;, v.b, \u0026#34;计算结果为：\u0026#34;, res) } 输出结果\nruntime error: integer divide by zero 2 / 2 计算结果为： 1  调用 panic 后，当前函数从调用点直接退出 recover 函数只有在 defer 代码块中才会有效果 recover 可以放在最外层函数，做统一异常处理。  3.4.8 小结 #  defer和panic是面试的高频题，因为在工作中非常常用。\n自定义错误的语法在正规项目中最为常用，可以和我一起实战一定能体验到了。\n"},{"id":20,"href":"/4.concurrent/4-1-go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%89%B9%E6%80%A7/","title":"4 1 Go语言中的并发特性","section":"4.concurrents","content":"4.1 go语言中的并发特性 #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/3.grammar-advancement/4.1-goroutine.go\n 以前我们写并发的程序一般是用多线程来实现，自己维护一个线程池，在恰当的时候创建、销毁、分配资源。\ngo 在并发方面为我们提供了一个语言级别的支持， goroutine 和 chan 相互配合，这决定了他的先天优势。\ngoroutine 的概念类似于线程， Go 程序运行时会自动调度和管理，系统能智能地将 goroutine 中的任务合理地分配给 CPU , 让这些任务尽量并发运作。\n4.1.1 他和线程对比 #  从使用上讲\n 比线程更轻量级，可以创建十万、百万不用担心资源问题。 和 chan 搭配使用，实现高并发， goroutine 之间传输数据更方便。 如果访问同一个数据块，要小心数据竞态问题、共享锁还是互斥锁的选择问题、并发操作的数据同步问题（后面会说）  从其实现上讲\n 从资源上讲，线程的栈内存大小一般是固定的一般为 2MB ，虽然这个数值可以设置，但是 太大了浪费，太小了容易不够用, 而 goroutine 栈内存是可变的，初始一般为 2KB ，随着需求可以扩大达到1GB。 所以 goroutine 十分的轻量级，且能满足不同的需求。 从调度上讲，线程的调度由 OS 的内核完成；线程的切换需要 CPU寄存器 和 内存的数据交换 ，从而切换不同的线程上下文。 其触发方式为 CPU时钟 , 而 goroutine 的调度则比较轻量级，由自身的调度器完成。 协程同线程的关系，有些类似于 线程同进程的关系。  4.1.2 创建与使用 #  创建一个 goroutine ，只需要在函数前加一个 go 关键字就成了。\ngo 函数名(参数) 看一个 dome\nfunc quickFun(){ fmt.Println(\u0026#34;maybe you can\u0026#39;s see me!\u0026#34;) } func main(){ go quickFun() // 创建了一个 goroutine \tfmt.Println(\u0026#34;hey\u0026#34;) time.Sleep(time.Second) }  goroutine 和 main 主线程同时运行 main 运行结束会暴力终止所有协程，所以上面的程序多等待了1秒 Go 程序从 main 包的 main() 函数开始，在程序启动时， Go 程序就会为 main() 函数创建一个默认的 goroutine 。  输出\nhey maybe you can's see me! 对，就是这么简单，如果你的函数只在这里使用，也可以用匿名函数来创建 goroutine 。\nfunc main(){ go func() { fmt.Println(\u0026#34;hello \u0026#34;) }() time.Sleep(time.Second) //main运行结束会暴力终止所有协程，所以这里先等待1秒 } PS: 和线程不同，goroutine没有唯一的id，所以我们没办法专门正对某个协程进行操作。\n4.1.3 goroutine #   本节源码位置 https://github.com/golang-minibear2333/golang/blob/master/3.grammar-advancement/4.2-goroutine.go\n goroutine 是 Go 语言并行设计的核心。goroutine 是一种比线程更轻量的实现，十几个 goroutine 可能在底层就是几个线程。 不同的是，Golang 在 runtime、系统调用等多方面对 goroutine 调度进行了封装和处理，当遇到长时间执行或者进行系统调用时，会主动把当前 goroutine 的 CPU (P) 转让出去，让其他 goroutine 能被调度并执行，也就是 Golang 从语言层面支持了协程。要使用 goroutine 只需要简单的在需要执行的函数前添加 go 关键字即可。当执行 goroutine 时候，Go 语言立即返回，接着执行剩余的代码，goroutine 不阻塞主线程。下面我们通过一小段代码来讲解 go 的使用：\n//首先我们先实现一个 Add()函数 func Add(a, b int) { c := a + b fmt.Println(c) } go Add(1, 2) //使用go关键字让函数并发执行 Go 的并发执行就是这么简单，当在一个函数前加上 go 关键字，该函数就会在一个新的 goroutine 中并发执行，当该函数执行完毕时，这个新的 goroutine 也就结束了。不过需要注意的是，如果该函数具有返回值，那么返回值会被丢弃。所以什么时候用 go 还需要酌情考虑。\n接着我们通过一个案例来体验一下 Go 的并发到底是怎么样的。新建源文件 goroutine.go，输入以下代码：\npackage main import \u0026#34;fmt\u0026#34; func Add(a, b int) { c := a + b fmt.Println(c) } func main() { for i := 0; i \u0026lt; 10; i++ { go Add(i, i) } } 执行 goroutine.go 文件会发现屏幕上什么都没有，但程序并不会报错，这是什么原因呢？原来当主程序执行到 for 循环时启动了 10 个 goroutine，然后主程序就退出了，而启动的 10 个 goroutine 还没来得及执行 Add() 函数，所以程序不会有任何输出。也就是说主 goroutine 并不会等待其他 goroutine 执行结束。那么如何解决这个问题呢？Go 语言提供的信道（channel）就是专门解决并发通信问题的，下一节我们将详细介绍。\n4.1.4 小结 #  学go语言必学并发，轻量协程，还要配合数据传输，生产者消费者模型，生产环境开发利器。\n但要并发bug是老大难了，要注意的事良好的代码风格，编程习惯。\n"},{"id":21,"href":"/books-share/","title":"Books Share","section":"Introduction","content":"书籍推荐 #  我读过或者我正在读，觉得不错的书，推荐给大家，欢迎评论推荐或者留下在线书籍链接\nPS：仅供学习，请勿传播\n入门 #    《go语言圣经》  实战（建议深入学习前部分实战拜读） #   《go web编程实战派》 比较基础和全面 《go语言编程之旅》蓝色封面，2020年出的书 更适合有一定基础的人  进阶 #   《go专家编程》 《go语言并发之道》 《go并发编程实战》 《Go语言高并发与微服务实战》  深入 #   《深入解析Go》 底层研究 《极客时间go语言36讲》对新人不友好，逻辑有些混乱，比较熟悉语言时再拜读，我读了一半实在看不下去  "},{"id":22,"href":"/goland/","title":"Goland","section":"Introduction","content":"Goland常用快捷键 #  文件相关快捷键：\n CTRL+E，打开最近浏览过的文件。 CTRL+SHIFT+E，打开最近更改的文件。 CTRL+N，可以快速打开struct结构体。 CTRL+SHIFT+N，可以快速打开文件。  代码格式化：\n CTRL+ALT+T，可以把代码包在一个块内，例如if{…}else{…}。 CTRL+ALT+L，格式化代码。 CTRL+空格，代码提示。 CTRL+/，单行注释。CTRL+SHIFT+/，进行多行注释。 CTRL+B，快速打开光标处的结构体或方法（跳转到定义处）。 CTRL+“+/-”，可以将当前方法进行展开或折叠。  查找和定位\n CTRL+R，替换文本。 CTRL+F，查找文本。 CTRL+SHIFT+F，进行全局查找。 CTRL+G，快速定位到某行。  代码编辑\n ALT+Q，可以看到当前方法的声明。 CTRL+Backspace，按单词进行删除。 SHIFT+ENTER，可以向下插入新行，即使光标在当前行的中间。 CTRL+X，删除当前光标所在行。 CTRL+D，复制当前光标所在行。 ALT+SHIFT+UP/DOWN，可以将光标所在行的代码上下移动。 CTRL+SHIFT+U，可以将选中内容进行大小写转化。  "},{"id":23,"href":"/howtocontribute/","title":"How to Contribute","section":"Introduction","content":"如何贡献项目 #  首先非常感谢你愿意参与贡献这个项目，让我们一起努力越做越好。\n参与贡献你可以参考下面的方法\nfork clone config #  在 GitHub 上fork到自己的仓库，如 xxx/golang，然后clone到本地，并设置用户信息。\n$ git clone git@github.com:xxx/golang.git $ cd golang $ git config user.name \u0026#34;yourname\u0026#34; $ git config user.email \u0026#34;your email\u0026#34; commit push #  修改代码后提交，并推送到自己的仓库。\n$ #do some change on the content $ git commit -m \u0026#34;Fix issue #1: change helo to hello\u0026#34; $ git push pr (pull request) #  在 GitHub 网站上提交 pull request。 当然了，如果你不会提pr，你可以参考我 给开源大项目贡献代码的文章\n到这里就完成贡献的整个过程了。\n同步代码 #  可以定期使用项目仓库内容更新自己仓库内容。\n$ git remote add upstream https://github.com/golang-minibear2333/golang $ git fetch upstream $ git checkout master $ git rebase upstream/master $ git push -f origin master 这样就可以把我以后的更新同步到你本地啦~!\n丰富的贡献方式 #  其实你也不必提交代码来贡献，如果你发现项目中有任何不足、bug，或者疑问、新需求，你可以通过issue的方式让我提出。\n我看到了会立刻给你回复\n"},{"id":24,"href":"/impossible/range/readme/","title":"Readme","section":"Impossibles","content":"for range的一个坑 #  for range是值拷贝出来的副本\n在使用for range的时候，要注意的是，不管是slice还是map，循环的值都是被range值拷贝出来的副本值。 举个简单的例了\n对于list\nvar t []Test t = append(t, Test{Index: 1, Num: 1}) t = append(t, Test{Index: 2, Num: 2}) // 实际上没有成功修改t.Num，因为是副本复制 \tfor _, v := range t { v.Num += 100 } for _, v := range t { // 输出 \t// 1 1 \t// 2 2 \tfmt.Println(v.Index, v.Num) } 对于 map, 也不能这么搞，实际上都是复制\nm := make(map[int]Test) m[0] = Test{Index: 1, Num: 1} m[1] = Test{Index: 2, Num: 2} for _, v := range m { v.Num += 100 } for _, v := range m { // 输出(可以乱序) \t// 1 1 \t// 2 2 \tfmt.Println(v.Index, v.Num) } 怎么做？ #  两个办法，用下标（map也一样）\nfor i := range t { t[i].Num += 100 fmt.Println(t[i].Num) // 输出(可以乱序) \t// 101 102 \t} 用指针\nvar t2 []*Test t2 = append(t2, \u0026amp;Test{Index: 1, Num: 1}) t2 = append(t2, \u0026amp;Test{Index: 2, Num: 2}) for k, v := range t2 { v.Num += 100 fmt.Println(t2[k].Num) // 输出(可以乱序) \t// 101 102 \t} for range 原理 #  通过查看 源代码 ，我们可以发现for range的实现是：\n# statements.cc:6419 (441f3f1 on 4 Oct) // Arrange to do a loop appropriate for the type. We will produce // for INIT ; COND ; POST { // ITER_INIT // INDEX = INDEX_TEMP // VALUE = VALUE_TEMP // If there is a value // original statements // } 并且对于Slice,Map等各有具体不同的编译实现,我们先看看for range slice的具体实现\n# statements.cc:6638 (441f3f1 on 4 Oct) // The loop we generate: // for_temp := range // len_temp := len(for_temp) // for index_temp = 0; index_temp \u0026lt; len_temp; index_temp++ { // value_temp = for_temp[index_temp] // index = index_temp // value = value_temp // original body // } 先是对要遍历的 Slice 做一个拷贝，获取长度大小，然后使用常规for循环进行遍历，并且返回值的拷贝。 再看看for range map的具体实现：\n# statements.cc:6891 (441f3f1 on 4 Oct) // The loop we generate: // var hiter map_iteration_struct // for mapiterinit(type, range, \u0026amp;hiter); hiter.key != nil; mapiternext(\u0026amp;hiter) { // index_temp = *hiter.key // value_temp = *hiter.val // index = index_temp // value = value_temp // original body // } 也是先对map进行了初始化，因为map是hashmap，所以这里其实是一个hashmap指针的拷贝。\n引用： Go 中for range的一个坑\n"},{"id":25,"href":"/qrcode/","title":"Qrcode","section":"Introduction","content":" "},{"id":26,"href":"/todo/","title":"Todo","section":"Introduction","content":"文章正在创作中 #  文章即将出炉，请耐心等待\u0026hellip;\u0026hellip;\n你可以：\n 加入我一起完成这篇文章，重新梳理知识体系 欢迎给我提 pr 如果你从来没有提过 pr，可以参考 我给开源项目提pr的过程，这是很重要的一种代码协作能力  再次感谢你的支持\n "},{"id":27,"href":"/tools/readme/","title":"Readme","section":"Tools","content":"golang小工具 #     作用 位置 备注     代码测速 speed.go    可超时缓存 cache.go 任意类型变量缓存，可设置超时时间   线程安全的缓存 map.go 任意类型变量缓存，线程安全   配置proxy static_proxy.go 简单配置http proxy   捕获panic defer_panic.go    重试函数 func.go 可传入函数和重试次数，自动重试，要求返回是否成功   参数 go命令行读取参数 -   文件写入读取 - -   配置文件 - -    "},{"id":28,"href":"/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/flag%E5%8C%85%E8%AF%BB%E5%8F%96%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%85%8D%E7%BD%AE/","title":"Flag包读取命令行配置","section":"番外.常用操作s","content":"简介 #  kingpin 功能比 flag 库强大，用法差不多。 相比 flag 库，最重要的一点就是支持不加 - 的调用。 比如一个命令行程序有三个函数分别为 A , B , C ，要实现根据命令行的输入运行不同的函数，如果用flag实现的话应该是下面这种使用方法：\n./cli --method A ./cli --method B ./cli --method C 每次都需要输入 --method ，然而用 kingpin 库实现的话就可以达到下面这种效果：\n./cli A ./cli B ./cli C 节省了很多输入操作。\n使用方法 #  go get gopkg.in/alecthomas/kingpin.v2 go mod vendor 这样子 go.mod 文件里就引入了， vendor 文件夹就缓存了此包，然后直接在代码中使用。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;gopkg.in/alecthomas/kingpin.v2\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { var ( listenAddress = kingpin.Flag( \u0026#34;web.listen-address\u0026#34;, \u0026#34;Address on which to expose metrics and web interface.\u0026#34;, ).Default(\u0026#34;:18001\u0026#34;).String() metricsPath = kingpin.Flag( \u0026#34;web.telemetry-path\u0026#34;, \u0026#34;Path under which to expose metrics.\u0026#34;, ).Default(\u0026#34;/metrics\u0026#34;).String() ) kingpin.HelpFlag.Short(\u0026#39;h\u0026#39;) kingpin.Parse() conf.ApiMtncUrl = *apiMtncPath http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(`\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Node Exporter\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;xxx Exporter\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a href=\u0026#34; ` + *metricsPath + ` \u0026#34;\u0026gt;Metrics\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;`)) }) http.Handle(\u0026#34;/metrics\u0026#34;, XXXX.Handler()) if err := http.ListenAndServe(*listenAddress, nil); err != nil { fmt.Printf(\u0026#34;Error occur when start server %v\u0026#34;, err) } } 官方文档参考 package kingpin \n引用 #   Golang命令行参数解析库kingpin\n"},{"id":29,"href":"/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/golang%E6%89%93%E9%95%9C%E5%83%8Fdockerfile%E7%9A%84%E5%86%99%E6%B3%95/","title":"Golang打镜像 Dockerfile的写法","section":"番外.常用操作s","content":"引言 #  对于dockerfile而言，何为完美? 我认为应该满足以下三点：\n 体积小 构建快 够安全  PS: 注意！从 Docker 17.05 版本起， Docker 才开始支持容器镜像的多阶段构建(multi-stage build)，所以本文所使用 docker 版本必须高于 17.05 （多阶段构建的意思就是把编译的过程也放同一个 Dockerfile 里，不用在自己的开发机或服务器上编译，再把编译出的二进制程序打入镜像）\n可联网的环境 #   根据官方的说法，从 Go 1.13 开始，模块管理模式将是 Go 语言开发的默认模式。\n 我们使用go mod 做包管理，就不需要有任何额外配置\nFROMgolang:1.13.5-alpine3.10 AS builderWORKDIR/buildRUN adduser -u 10001 -D app-runnerENV GOPROXY https://goproxy.cnCOPY go.mod .COPY go.sum .RUN go mod downloadCOPY . .RUN CGO_ENABLED=0 GOARCH=amd64 GOOS=linux go build -a -o your-application .FROMalpine:3.10 AS finalWORKDIR/appCOPY --from=builder /build/your-application /app/#COPY --from=builder /build/config /app/configCOPY --from=builder /etc/passwd /etc/passwdCOPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/USERapp-runnerENTRYPOINT [\u0026#34;/app/your-application\u0026#34;]逐行拆解 这里的拆解完全引用 手把手教你写一个完美的Golang Dockerfile\n首先，这个dockerfile分为builder和final两部分。\nbuilder 选择了 golang:1.13.5-alpine3.10 作为编译的基础镜像，相比于 golang:1.13 , 一方面是因为它体积更小，另一方面是我发现 golang:1.13 的编译结果，在 alpine:3.10 中会报 not found 的错误，虽说有人提供了其它的解决方案，但是能直接避免，为啥不避免呢。\nRUN adduser -u 10001 -D app-runner接着是创建了一个 app-runner 的用户, -D 表示无密码。\n此用户的信息是是需要拷到 final 中，作为应用程序的启动用户。这是为了避免使用 container 中的默认用户 root ，那可是有安全漏洞的，详细解释，可以参考这篇 medium 上的文章 Processes In Containers Should Not Run As Root\n再下面的四行，\nENV GOPROXY https://goproxy.cnCOPY go.mod .COPY go.sum .RUN go mod download是配置了国内的代理，安装依赖包了。这里用 go mod download 的好处是下次构建镜像文件时，当go.mod和go.sum没有改变时，它是有缓存的，可以避免重复下载依赖包，加快构建。\nbuilder的最后，就是把当前目录的文件拷过去，编译代码了。\nCOPY . .RUN CGO_ENABLED=0 GOARCH=amd64 GOOS=linux go build -a -o your-application .final 选择了 alpine:3.10 ,一方面是体积小，只有 5m ；另一方面也是和构建镜像的 alpine 版本保持一致。\n接下来几行没啥说的，就是把构建结果、配置文件（有的话）和用户的相关文件拷过去。\n下面的这步一定不要忘记了，\nUSERapp-runner没有它， container 启动时就是用 root 用户启动了!!! 如果被攻击了，那黑客可是就有 root 权限了（不要问我为啥会被攻击）。\n最后，设置一个 ENTRYPOINT ，完事!\n如果你程序的启动过程比较复杂，或者是要在启动时根据环境变量的值做不同的操作，那还是写个 shell 文件吧。\n离线打包 #  # Building stageFROMgolang:1.13.5-alpine3.10 AS builderWORKDIR/build/src/your-applicationRUN adduser -u 10001 -D app-runnerENV GO111MODULE offENV GOPATH /buildCOPY . .RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -o your-application main.go#RUN CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -o your-application main.go# Production stageFROMalpine:3.10 AS finalWORKDIR/appCOPY --from=builder /build/src/your-application/example/linux /appCOPY --from=builder /build/src/your-application/your-application /app#COPY --from=builder /build/src/your-application/conf /app/confRUN adduser -u 10001 -D app-runnerRUN chmod -R 755 /appENTRYPOINT [\u0026#34;/app/your-application\u0026#34;]如果你的环境是内网，不能连接外网（不能联网），要从外部导入一个 go mod 项目，并运行的时候，肯定会 timeout 在下载项目依赖的包的阶段，实际上依赖包已经放到目录文件，不用下载也能正常运行。为了解决这一问题，我们只需要设置参数 GO111MODULE=off ，然后设置正确的 GOPATH 即可\nENV GO111MODULE offENV GOPATH /build在代码库中需要提前把代码包的中 vendor 更新，在本地执行以下命令，并提交到代码库\ngo mod init your-application go mod vendor 这样就会有离线的 vendor 代码库\n |——vendor └──github.com └──golang.org └──gopkg.in └──modules.txt  GO111MODULE=off 无 mod 支持， go 会从 GOPATH 和 vendor 文件夹寻找包。 GO111MODULE=on 模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。 GO111MODULE=auto 在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。  有可能会遇到的问题 #  docker镜像源速度慢 #  如果docker镜像拉取速度太慢，或者拉取不到，可以试试改为国内镜像源地址，参考 这里\n更新docker的yum源 #  如果你发现自己的docker版本低，但是自己的源里面又没有想要的版本，那就需要更新官方的源 参考 这里\n引用 #   手把手教你写一个完美的Golang Dockerfile Golang1.5到Golang1.12包管理：golang vendor 到 go mod 官方golang包管理神器，值得一试！go mod | 编程三分钟\n"},{"id":30,"href":"/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/go%E4%BB%A3%E7%A0%81%E5%9F%BA%E6%9C%AC%E6%A0%87%E5%87%86%E8%A7%84%E8%8C%83/","title":"Go代码基本标准规范","section":"番外.常用操作s","content":"文档 #   不刻意制定详细文档 编码级别文档化，支持一键导出文档  统一的标准和习惯，提高可读性 #  三个统一\n 统一的日志 统一的接口规范：错误码、返回格式、国际化 统一编码习惯  统一编码习惯 #  变量常量\n 变量必须见名知义不得用拼音，且长度在 3-20 个字母 名词必须单数 常量必须全大写  所有程序必须有注释\n提交记录必须指明 tapd 单号，功能，更新记录\n代码文件名\n 必须见名知义，保证内部代码单一职责 文件夹必须与包名保持一致，全小写，尽量使用短命名，不能使用下划线、中划线等字符  函数\n 单个函数长度不超过 50 行 参数个数不要超过 5 个（参数过多通常意味着缺少封装，不易维护，容易出错） 函数返回值个数不要超过 3 个，如果超过，建议将其中关系密切的返回值参数封装成一个结构体。  格式化要求 提交代码时，必须使用 gofmt 对代码进行格式化 提交代码时，必须使用 golint 对代码进行检查。 字符串形式的 json 时，使用反单引号，而不是双引号。\n\u0026#34;{\\\u0026#34;key\\\u0026#34;:\\\u0026#34;value\\\u0026#34;}\u0026#34; 改为格式更清晰的：\n` { \u0026#34;key\u0026#34;:\u0026#34;value\u0026#34; } ` 如果有其他建议欢迎补充\n"},{"id":31,"href":"/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8/","title":"Go文件操作大全","section":"番外.常用操作s","content":"Go 官方库的文件操作分散在多个包中，比如os、ioutil包，我本来想写一篇总结性的 Go 文件操作的文章，却发现已经有人 2015 年已经写了一篇这样的文章，写的非常好，所以我翻译成了中文，强烈推荐你阅读一下。\n原文: Working with Files in Go, 作者: NanoDano\n介绍 #  万物皆文件 #  UNIX 的一个基础设计就是\u0026quot;万物皆文件\u0026quot;(everything is a file)。我们不必知道一个文件到底映射成什么，操作系统的设备驱动抽象成文件。操作系统为设备提供了文件格式的接口。\nGo 语言中的 reader 和 writer 接口也类似。我们只需简单的读写字节，不必知道 reader 的数据来自哪里，也不必知道 writer 将数据发送到哪里。\n你可以在/dev下查看可用的设备，有些可能需要较高的权限才能访问。\n基本操作 #  创建空文件 #  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) var ( newFile *os.File err error ) func main() { newFile, err = os.Create(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } log.Println(newFile) newFile.Close() } Truncate 文件 #  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 裁剪一个文件到100个字节。  // 如果文件本来就少于100个字节，则文件中原始内容得以保留，剩余的字节以null字节填充。  // 如果文件本来超过100个字节，则超过的字节会被抛弃。  // 这样我们总是得到精确的100个字节的文件。  // 传入0则会清空文件。  err := os.Truncate(\u0026#34;test.txt\u0026#34;, 100) if err != nil { log.Fatal(err) } } 得到文件信息 #  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) var ( fileInfo os.FileInfo err error ) func main() { // 如果文件不存在，则返回错误  fileInfo, err = os.Stat(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;File name:\u0026#34;, fileInfo.Name()) fmt.Println(\u0026#34;Size in bytes:\u0026#34;, fileInfo.Size()) fmt.Println(\u0026#34;Permissions:\u0026#34;, fileInfo.Mode()) fmt.Println(\u0026#34;Last modified:\u0026#34;, fileInfo.ModTime()) fmt.Println(\u0026#34;Is Directory: \u0026#34;, fileInfo.IsDir()) fmt.Printf(\u0026#34;System interface type: %T\\\\n\u0026#34;, fileInfo.Sys()) fmt.Printf(\u0026#34;System info: %+v\\\\n\\\\n\u0026#34;, fileInfo.Sys()) } 重命名和移动 #  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { originalPath := \u0026#34;test.txt\u0026#34; newPath := \u0026#34;test2.txt\u0026#34; err := os.Rename(originalPath, newPath) if err != nil { log.Fatal(err) } }  译者按： rename 和 move 原理一样\n 删除文件 #  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { err := os.Remove(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } } 打开和关闭文件 #  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 简单地以只读的方式打开。下面的例子会介绍读写的例子。  file, err := os.Open(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } file.Close() // OpenFile提供更多的选项。  // 最后一个参数是权限模式permission mode  // 第二个是打开时的属性  file, err = os.OpenFile(\u0026#34;test.txt\u0026#34;, os.O_APPEND, 0666) if err != nil { log.Fatal(err) } file.Close() // 下面的属性可以单独使用，也可以组合使用。  // 组合使用时可以使用 OR 操作设置 OpenFile的第二个参数，例如：  // os.O\\_CREATE|os.O\\_APPEND  // 或者 os.O\\_CREATE|os.O\\_TRUNC|os.O_WRONLY  // os.O_RDONLY // 只读  // os.O_WRONLY // 只写  // os.O_RDWR // 读写  // os.O_APPEND // 往文件中添建（Append）  // os.O_CREATE // 如果文件不存在则先创建  // os.O_TRUNC // 文件打开时裁剪文件  // os.O\\_EXCL // 和O\\_CREATE一起使用，文件不能存在  // os.O_SYNC // 以同步I/O的方式打开  }  译者按：熟悉 Linux 的读者应该很熟悉权限模式，通过 Linux 命令chmod可以更改文件的权限\nhttps://www.linux.com/learn/understanding-linux-file-permissions\n补充了原文未介绍的 flag\n 检查文件是否存在 #  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) var ( fileInfo *os.FileInfo err error ) func main() { // 文件不存在则返回error  fileInfo, err := os.Stat(\u0026#34;test.txt\u0026#34;) if err != nil { if os.IsNotExist(err) { log.Fatal(\u0026#34;File does not exist.\u0026#34;) } } log.Println(\u0026#34;File does exist. File information:\u0026#34;) log.Println(fileInfo) } 检查读写权限 #  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 这个例子测试写权限，如果没有写权限则返回error。  // 注意文件不存在也会返回error，需要检查error的信息来获取到底是哪个错误导致。  file, err := os.OpenFile(\u0026#34;test.txt\u0026#34;, os.O_WRONLY, 0666) if err != nil { if os.IsPermission(err) { log.Println(\u0026#34;Error: Write permission denied.\u0026#34;) } } file.Close() // 测试读权限  file, err = os.OpenFile(\u0026#34;test.txt\u0026#34;, os.O_RDONLY, 0666) if err != nil { if os.IsPermission(err) { log.Println(\u0026#34;Error: Read permission denied.\u0026#34;) } } file.Close() } 改变权限、拥有者、时间戳 #  package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 使用Linux风格改变文件权限  err := os.Chmod(\u0026#34;test.txt\u0026#34;, 0777) if err != nil { log.Println(err) } // 改变文件所有者  err = os.Chown(\u0026#34;test.txt\u0026#34;, os.Getuid(), os.Getgid()) if err != nil { log.Println(err) } // 改变时间戳  twoDaysFromNow := time.Now().Add(48 \\* time.Hour) lastAccessTime := twoDaysFromNow lastModifyTime := twoDaysFromNow err = os.Chtimes(\u0026#34;test.txt\u0026#34;, lastAccessTime, lastModifyTime) if err != nil { log.Println(err) } } 硬链接和软链接 #  一个普通的文件是一个指向硬盘的 inode 的地方。\n硬链接创建一个新的指针指向同一个地方。只有所有的链接被删除后文件才会被删除。硬链接只在相同的文件系统中才工作。你可以认为一个硬链接是一个正常的链接。\nsymbolic link，又叫软连接，和硬链接有点不一样，它不直接指向硬盘中的相同的地方，而是通过名字引用其它文件。他们可以指向不同的文件系统中的不同文件。并不是所有的操作系统都支持软链接。\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;log\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { // 创建一个硬链接。  // 创建后同一个文件内容会有两个文件名，改变一个文件的内容会影响另一个。  // 删除和重命名不会影响另一个。  err := os.Link(\u0026#34;original.txt\u0026#34;, \u0026#34;original_also.txt\u0026#34;) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;creating sym\u0026#34;) // Create a symlink  err = os.Symlink(\u0026#34;original.txt\u0026#34;, \u0026#34;original_sym.txt\u0026#34;) if err != nil { log.Fatal(err) } // Lstat返回一个文件的信息，但是当文件是一个软链接时，它返回软链接的信息，而不是引用的文件的信息。  // Symlink在Windows中不工作。  fileInfo, err := os.Lstat(\u0026#34;original_sym.txt\u0026#34;) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Link info: %+v\u0026#34;, fileInfo) //改变软链接的拥有者不会影响原始文件。  err = os.Lchown(\u0026#34;original_sym.txt\u0026#34;, os.Getuid(), os.Getgid()) if err != nil { log.Fatal(err) } } 读写 #  复制文件 #  package main import ( \u0026#34;os\u0026#34; \u0026#34;log\u0026#34; \u0026#34;io\u0026#34; ) func main() { // 打开原始文件  originalFile, err := os.Open(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } defer originalFile.Close() // 创建新的文件作为目标文件  newFile, err := os.Create(\u0026#34;test_copy.txt\u0026#34;) if err != nil { log.Fatal(err) } defer newFile.Close() // 从源中复制字节到目标文件  bytesWritten, err := io.Copy(newFile, originalFile) if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Copied %d bytes.\u0026#34;, bytesWritten) // 将文件内容flush到硬盘中  err = newFile.Sync() if err != nil { log.Fatal(err) } } 跳转到文件指定位置(Seek) #  package main import ( \u0026#34;os\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; ) func main() { file, _ := os.Open(\u0026#34;test.txt\u0026#34;) defer file.Close() // 偏离位置，可以是正数也可以是负数  var offset int64 = 5 // 用来计算offset的初始位置  // 0 = 文件开始位置  // 1 = 当前位置  // 2 = 文件结尾处  var whence int = 0 newPosition, err := file.Seek(offset, whence) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Just moved to 5:\u0026#34;, newPosition) // 从当前位置回退两个字节  newPosition, err = file.Seek(-2, 1) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Just moved back two:\u0026#34;, newPosition) // 使用下面的技巧得到当前的位置  currentPosition, err := file.Seek(0, 1) fmt.Println(\u0026#34;Current position:\u0026#34;, currentPosition) // 转到文件开始处  newPosition, err = file.Seek(0, 0) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Position after seeking 0,0:\u0026#34;, newPosition) } 写文件 #  可以使用os包写入一个打开的文件。\n因为 Go 可执行包是静态链接的可执行文件，你 import 的每一个包都会增加你的可执行文件的大小。其它的包如io、｀ ioutil ｀、｀ bufio ｀提供了一些方法，但是它们不是必须的。\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;log\u0026#34; ) func main() { // 可写方式打开文件  file, err := os.OpenFile( \u0026#34;test.txt\u0026#34;, os.O\\_WRONLY|os.O\\_TRUNC|os.O_CREATE, 0666, ) if err != nil { log.Fatal(err) } defer file.Close() // 写字节到文件中  byteSlice := \\[\\]byte(\u0026#34;Bytes!\\\\n\u0026#34;) bytesWritten, err := file.Write(byteSlice) if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Wrote %d bytes.\\\\n\u0026#34;, bytesWritten) } 快写文件 #  ioutil包有一个非常有用的方法WriteFile()可以处理创建／打开文件、写字节 slice 和关闭文件一系列的操作。如果你需要简洁快速地写字节 slice 到文件中，你可以使用它。\npackage main import ( \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; ) func main() { err := ioutil.WriteFile(\u0026#34;test.txt\u0026#34;, \\[\\]byte(\u0026#34;Hi\\\\n\u0026#34;), 0666) if err != nil { log.Fatal(err) } } 使用缓存写 #  bufio包提供了带缓存功能的 writer，所以你可以在写字节到硬盘前使用内存缓存。当你处理很多的数据很有用，因为它可以节省操作硬盘 I/O 的时间。在其它一些情况下它也很有用，比如你每次写一个字节，把它们攒在内存缓存中，然后一次写入到硬盘中，减少硬盘的磨损以及提升性能。\npackage main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;bufio\u0026#34; ) func main() { // 打开文件，只写  file, err := os.OpenFile(\u0026#34;test.txt\u0026#34;, os.O_WRONLY, 0666) if err != nil { log.Fatal(err) } defer file.Close() // 为这个文件创建buffered writer  bufferedWriter := bufio.NewWriter(file) // 写字节到buffer  bytesWritten, err := bufferedWriter.Write( \\[\\]byte{65, 66, 67}, ) if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Bytes written: %d\\\\n\u0026#34;, bytesWritten) // 写字符串到buffer  // 也可以使用 WriteRune() 和 WriteByte()  bytesWritten, err = bufferedWriter.WriteString( \u0026#34;Buffered string\\\\n\u0026#34;, ) if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Bytes written: %d\\\\n\u0026#34;, bytesWritten) // 检查缓存中的字节数  unflushedBufferSize := bufferedWriter.Buffered() log.Printf(\u0026#34;Bytes buffered: %d\\\\n\u0026#34;, unflushedBufferSize) // 还有多少字节可用（未使用的缓存大小）  bytesAvailable := bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Available buffer: %d\\\\n\u0026#34;, bytesAvailable) // 写内存buffer到硬盘  bufferedWriter.Flush() // 丢弃还没有flush的缓存的内容，清除错误并把它的输出传给参数中的writer  // 当你想将缓存传给另外一个writer时有用  bufferedWriter.Reset(bufferedWriter) bytesAvailable = bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Available buffer: %d\\\\n\u0026#34;, bytesAvailable) // 重新设置缓存的大小。  // 第一个参数是缓存应该输出到哪里，这个例子中我们使用相同的writer。  // 如果我们设置的新的大小小于第一个参数writer的缓存大小， 比如10，我们不会得到一个10字节大小的缓存，  // 而是writer的原始大小的缓存，默认是4096。  // 它的功能主要还是为了扩容。  bufferedWriter = bufio.NewWriterSize( bufferedWriter, 8000, ) // resize后检查缓存的大小  bytesAvailable = bufferedWriter.Available() if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Available buffer: %d\\\\n\u0026#34;, bytesAvailable) } 读取最多 N 个字节 #  os.File提供了文件操作的基本功能， 而io、ioutil、bufio提供了额外的辅助函数。\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;log\u0026#34; ) func main() { // 打开文件，只读  file, err := os.Open(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() // 从文件中读取len(b)字节的文件。  // 返回0字节意味着读取到文件尾了  // 读取到文件会返回io.EOF的error  byteSlice := make(\\[\\]byte, 16) bytesRead, err := file.Read(byteSlice) if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Number of bytes read: %d\\\\n\u0026#34;, bytesRead) log.Printf(\u0026#34;Data read: %s\\\\n\u0026#34;, byteSlice) } 读取正好 N 个字节 #  package main import ( \u0026#34;os\u0026#34; \u0026#34;log\u0026#34; \u0026#34;io\u0026#34; ) func main() { // Open file for reading  file, err := os.Open(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } // file.Read()可以读取一个小文件到大的byte slice中，  // 但是io.ReadFull()在文件的字节数小于byte slice字节数的时候会返回错误  byteSlice := make(\\[\\]byte, 2) numBytesRead, err := io.ReadFull(file, byteSlice) if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Number of bytes read: %d\\\\n\u0026#34;, numBytesRead) log.Printf(\u0026#34;Data read: %s\\\\n\u0026#34;, byteSlice) } 读取至少 N 个字节 #  package main import ( \u0026#34;os\u0026#34; \u0026#34;log\u0026#34; \u0026#34;io\u0026#34; ) func main() { // 打开文件，只读  file, err := os.Open(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } byteSlice := make(\\[\\]byte, 512) minBytes := 8 // io.ReadAtLeast()在不能得到最小的字节的时候会返回错误，但会把已读的文件保留  numBytesRead, err := io.ReadAtLeast(file, byteSlice, minBytes) if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Number of bytes read: %d\\\\n\u0026#34;, numBytesRead) log.Printf(\u0026#34;Data read: %s\\\\n\u0026#34;, byteSlice) } 读取全部字节 #  package main import ( \u0026#34;os\u0026#34; \u0026#34;log\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; ) func main() { file, err := os.Open(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } // os.File.Read(), io.ReadFull() 和  // io.ReadAtLeast() 在读取之前都需要一个固定大小的byte slice。  // 但ioutil.ReadAll()会读取reader(这个例子中是file)的每一个字节，然后把字节slice返回。  data, err := ioutil.ReadAll(file) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Data as hex: %x\\\\n\u0026#34;, data) fmt.Printf(\u0026#34;Data as string: %s\\\\n\u0026#34;, data) fmt.Println(\u0026#34;Number of bytes read:\u0026#34;, len(data)) } 快读到内存 #  package main import ( \u0026#34;log\u0026#34; \u0026#34;io/ioutil\u0026#34; ) func main() { // 读取文件到byte slice中  data, err := ioutil.ReadFile(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Data read: %s\\\\n\u0026#34;, data) } 使用缓存读 #  有缓存写也有缓存读。\n缓存 reader 会把一些内容缓存在内存中。它会提供比os.File和io.Reader更多的函数,缺省的缓存大小是 4096，最小缓存是 16。\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;log\u0026#34; \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { // 打开文件，创建buffered reader  file, err := os.Open(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } bufferedReader := bufio.NewReader(file) // 得到字节，当前指针不变  byteSlice := make(\\[\\]byte, 5) byteSlice, err = bufferedReader.Peek(5) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Peeked at 5 bytes: %s\\\\n\u0026#34;, byteSlice) // 读取，指针同时移动  numBytesRead, err := bufferedReader.Read(byteSlice) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Read %d bytes: %s\\\\n\u0026#34;, numBytesRead, byteSlice) // 读取一个字节, 如果读取不成功会返回Error  myByte, err := bufferedReader.ReadByte() if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Read 1 byte: %c\\\\n\u0026#34;, myByte) // 读取到分隔符，包含分隔符，返回byte slice  dataBytes, err := bufferedReader.ReadBytes(\u0026#39;\\\\n\u0026#39;) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Read bytes: %s\\\\n\u0026#34;, dataBytes) // 读取到分隔符，包含分隔符，返回字符串  dataString, err := bufferedReader.ReadString(\u0026#39;\\\\n\u0026#39;) if err != nil { log.Fatal(err) } fmt.Printf(\u0026#34;Read string: %s\\\\n\u0026#34;, dataString) //这个例子读取了很多行，所以test.txt应该包含多行文本才不至于出错  } 使用 scanner #  Scanner是bufio包下的类型,在处理文件中以分隔符分隔的文本时很有用。\n通常我们使用换行符作为分隔符将文件内容分成多行。在 CSV 文件中，逗号一般作为分隔符。\nos.File文件可以被包装成bufio.Scanner，它就像一个缓存 reader。\n我们会调用Scan()方法去读取下一个分隔符，使用Text()或者Bytes()获取读取的数据。\n分隔符可以不是一个简单的字节或者字符，有一个特殊的方法可以实现分隔符的功能，以及将指针移动多少，返回什么数据。\n如果没有定制的SplitFunc提供，缺省的ScanLines会使用newline字符作为分隔符，其它的分隔函数还包括ScanRunes和ScanWords,皆在bufio包中。\n// To define your own split function, match this fingerprint  type SplitFunc func(data \\[\\]byte, atEOF bool) (advance int, token \\[\\]byte, err error) // Returning (0, nil, nil) will tell the scanner  // to scan again, but with a bigger buffer because  // it wasn\u0026#39;t enough data to reach the delimiter 下面的例子中，为一个文件创建了bufio.Scanner，并按照单词逐个读取：\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;log\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;bufio\u0026#34; ) func main() { file, err := os.Open(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } scanner := bufio.NewScanner(file) // 缺省的分隔函数是bufio.ScanLines,我们这里使用ScanWords。  // 也可以定制一个SplitFunc类型的分隔函数  scanner.Split(bufio.ScanWords) // scan下一个token.  success := scanner.Scan() if success == false { // 出现错误或者EOF是返回Error  err = scanner.Err() if err == nil { log.Println(\u0026#34;Scan completed and reached EOF\u0026#34;) } else { log.Fatal(err) } } // 得到数据，Bytes() 或者 Text()  fmt.Println(\u0026#34;First word found:\u0026#34;, scanner.Text()) // 再次调用scanner.Scan()发现下一个token  } 压缩 #  打包(zip) 文件 #  // This example uses zip but standard library  // also supports tar archives  package main import ( \u0026#34;archive/zip\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 创建一个打包文件  outFile, err := os.Create(\u0026#34;test.zip\u0026#34;) if err != nil { log.Fatal(err) } defer outFile.Close() // 创建zip writer  zipWriter := zip.NewWriter(outFile) // 往打包文件中写文件。  // 这里我们使用硬编码的内容，你可以遍历一个文件夹，把文件夹下的文件以及它们的内容写入到这个打包文件中。  var filesToArchive = \\[\\]struct { Name, Body string } { {\u0026#34;test.txt\u0026#34;, \u0026#34;String contents of file\u0026#34;}, {\u0026#34;test2.txt\u0026#34;, \u0026#34;\\\\x61\\\\x62\\\\x63\\\\n\u0026#34;}, } // 下面将要打包的内容写入到打包文件中，依次写入。  for _, file := range filesToArchive { fileWriter, err := zipWriter.Create(file.Name) if err != nil { log.Fatal(err) } _, err = fileWriter.Write(\\[\\]byte(file.Body)) if err != nil { log.Fatal(err) } } // 清理  err = zipWriter.Close() if err != nil { log.Fatal(err) } } 抽取(unzip) 文件 #  // This example uses zip but standard library  // also supports tar archives  package main import ( \u0026#34;archive/zip\u0026#34; \u0026#34;log\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) func main() { zipReader, err := zip.OpenReader(\u0026#34;test.zip\u0026#34;) if err != nil { log.Fatal(err) } defer zipReader.Close() // 遍历打包文件中的每一文件/文件夹  for _, file := range zipReader.Reader.File { // 打包文件中的文件就像普通的一个文件对象一样  zippedFile, err := file.Open() if err != nil { log.Fatal(err) } defer zippedFile.Close() // 指定抽取的文件名。  // 你可以指定全路径名或者一个前缀，这样可以把它们放在不同的文件夹中。  // 我们这个例子使用打包文件中相同的文件名。  targetDir := \u0026#34;./\u0026#34; extractedFilePath := filepath.Join( targetDir, file.Name, ) // 抽取项目或者创建文件夹  if file.FileInfo().IsDir() { // 创建文件夹并设置同样的权限  log.Println(\u0026#34;Creating directory:\u0026#34;, extractedFilePath) os.MkdirAll(extractedFilePath, file.Mode()) } else { //抽取正常的文件  log.Println(\u0026#34;Extracting file:\u0026#34;, file.Name) outputFile, err := os.OpenFile( extractedFilePath, os.O\\_WRONLY|os.O\\_CREATE|os.O_TRUNC, file.Mode(), ) if err != nil { log.Fatal(err) } defer outputFile.Close() // 通过io.Copy简洁地复制文件内容  _, err = io.Copy(outputFile, zippedFile) if err != nil { log.Fatal(err) } } } } 压缩文件 #  // 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw  package main import ( \u0026#34;os\u0026#34; \u0026#34;compress/gzip\u0026#34; \u0026#34;log\u0026#34; ) func main() { outputFile, err := os.Create(\u0026#34;test.txt.gz\u0026#34;) if err != nil { log.Fatal(err) } gzipWriter := gzip.NewWriter(outputFile) defer gzipWriter.Close() // 当我们写如到gizp writer数据时，它会依次压缩数据并写入到底层的文件中。  // 我们不必关心它是如何压缩的，还是像普通的writer一样操作即可。  _, err = gzipWriter.Write(\\[\\]byte(\u0026#34;Gophers rule!\\\\n\u0026#34;)) if err != nil { log.Fatal(err) } log.Println(\u0026#34;Compressed data written to file.\u0026#34;) } 解压缩文件 #  // 这个例子中使用gzip压缩格式，标准库还支持zlib, bz2, flate, lzw  package main import ( \u0026#34;compress/gzip\u0026#34; \u0026#34;log\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { // 打开一个gzip文件。  // 文件是一个reader,但是我们可以使用各种数据源，比如web服务器返回的gzipped内容，  // 它的内容不是一个文件，而是一个内存流  gzipFile, err := os.Open(\u0026#34;test.txt.gz\u0026#34;) if err != nil { log.Fatal(err) } gzipReader, err := gzip.NewReader(gzipFile) if err != nil { log.Fatal(err) } defer gzipReader.Close() // 解压缩到一个writer,它是一个file writer  outfileWriter, err := os.Create(\u0026#34;unzipped.txt\u0026#34;) if err != nil { log.Fatal(err) } defer outfileWriter.Close() // 复制内容  _, err = io.Copy(outfileWriter, gzipReader) if err != nil { log.Fatal(err) } } 其它 #  临时文件和目录 #  ioutil提供了两个函数: TempDir() 和 TempFile()。\n使用完毕后，调用者负责删除这些临时文件和文件夹。\n有一点好处就是当你传递一个空字符串作为文件夹名的时候，它会在操作系统的临时文件夹中创建这些项目（/tmp on Linux）。\nos.TempDir()返回当前操作系统的临时文件夹。\npackage main import ( \u0026#34;os\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;fmt\u0026#34; ) func main() { // 在系统临时文件夹中创建一个临时文件夹  tempDirPath, err := ioutil.TempDir(\u0026#34;\u0026#34;, \u0026#34;myTempDir\u0026#34;) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Temp dir created:\u0026#34;, tempDirPath) // 在临时文件夹中创建临时文件  tempFile, err := ioutil.TempFile(tempDirPath, \u0026#34;myTempFile.txt\u0026#34;) if err != nil { log.Fatal(err) } fmt.Println(\u0026#34;Temp file created:\u0026#34;, tempFile.Name()) // ... 做一些操作 ...  // 关闭文件  err = tempFile.Close() if err != nil { log.Fatal(err) } // 删除我们创建的资源  err = os.Remove(tempFile.Name()) if err != nil { log.Fatal(err) } err = os.Remove(tempDirPath) if err != nil { log.Fatal(err) } } 通过 HTTP 下载文件 #  package main import ( \u0026#34;os\u0026#34; \u0026#34;io\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { newFile, err := os.Create(\u0026#34;devdungeon.html\u0026#34;) if err != nil { log.Fatal(err) } defer newFile.Close() url := \u0026#34;http://www.devdungeon.com/archive\u0026#34; response, err := http.Get(url) defer response.Body.Close() // 将HTTP response Body中的内容写入到文件  // Body满足reader接口，因此我们可以使用ioutil.Copy  numBytesWritten, err := io.Copy(newFile, response.Body) if err != nil { log.Fatal(err) } log.Printf(\u0026#34;Downloaded %d byte file.\\\\n\u0026#34;, numBytesWritten) } 哈希和摘要 #  package main import ( \u0026#34;crypto/md5\u0026#34; \u0026#34;crypto/sha1\u0026#34; \u0026#34;crypto/sha256\u0026#34; \u0026#34;crypto/sha512\u0026#34; \u0026#34;log\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; ) func main() { // 得到文件内容  data, err := ioutil.ReadFile(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } // 计算Hash  fmt.Printf(\u0026#34;Md5: %x\\\\n\\\\n\u0026#34;, md5.Sum(data)) fmt.Printf(\u0026#34;Sha1: %x\\\\n\\\\n\u0026#34;, sha1.Sum(data)) fmt.Printf(\u0026#34;Sha256: %x\\\\n\\\\n\u0026#34;, sha256.Sum256(data)) fmt.Printf(\u0026#34;Sha512: %x\\\\n\\\\n\u0026#34;, sha512.Sum512(data)) } 上面的例子复制整个文件内容到内存中，传递给 hash 函数。\n另一个方式是创建一个 hash writer, 使用Write、WriteString、Copy将数据传给它。\n下面的例子使用 md5 hash,但你可以使用其它的 Writer。\npackage main import ( \u0026#34;crypto/md5\u0026#34; \u0026#34;log\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; ) func main() { file, err := os.Open(\u0026#34;test.txt\u0026#34;) if err != nil { log.Fatal(err) } defer file.Close() //创建一个新的hasher,满足writer接口  hasher := md5.New() _, err = io.Copy(hasher, file) if err != nil { log.Fatal(err) } // 计算hash并打印结果。  // 传递 nil 作为参数，因为我们不通参数传递数据，而是通过writer接口。  sum := hasher.Sum(nil) fmt.Printf(\u0026#34;Md5 checksum: %x\\\\n\u0026#34;, sum) } 参考 #   Go Standard Library Documentation\n"},{"id":32,"href":"/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E5%88%87%E7%89%87%E6%8E%92%E5%BA%8Fsort%E5%8C%85%E7%9A%84%E4%BD%BF%E7%94%A8/","title":"切片排序sort包的使用","section":"番外.常用操作s","content":"golang的sort包提供了部分切片排序的函数和用户自定义数据集的函数。\n排序切片 #  func Example1() { arry := []int{5,8,3,1,4,2,7,6} fmt.Println(arry) sort.Ints(arry) fmt.Println(arry) // Output:  // [5 8 3 1 4 2 7 6]  // [1 2 3 4 5 6 7 8] } 排序用户自定义数据集 #  type Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(\u0026#34;%s: %d\u0026#34;, p.Name, p.Age) } // ByAge implements sort.Interface for []Person based on // the Age field. type ByAge []Person func (a ByAge) Len() int { return len(a) } func (a ByAge) Swap(i, j int) { a[i], a[j] = a[j], a[i] } func (a ByAge) Less(i, j int) bool { return a[i].Age \u0026lt; a[j].Age } func Example2() { people := []Person{ {\u0026#34;Bob\u0026#34;, 31}, {\u0026#34;John\u0026#34;, 42}, {\u0026#34;Michael\u0026#34;, 17}, {\u0026#34;Jenny\u0026#34;, 26}, } fmt.Println(people) sort.Sort(ByAge(people)) fmt.Println(people) // Output:  // [Bob: 31 John: 42 Michael: 17 Jenny: 26]  // [Michael: 17 Jenny: 26 Bob: 31 John: 42] } 按选定的Key排序自定义数据集 #  type stature float32 type weight float32 type Pepole struct { name string h stature w weight } // By is the type of a \u0026#34;less\u0026#34; function that defines the ordering of its Pepole arguments. type By func(p1, p2 *Pepole) bool // Sort is a method on the function type, By, that sorts the argument slice according to the function. func (by By) Sort(p []Pepole) { ps := \u0026amp;pepoleSorter{ pepole: pepole, by: by, // The Sort method\u0026#39;s receiver is the function (closure) that defines the sort order.  } sort.Sort(ps) } // pepoleSorter joins a By function and a slice of Pepole to be sorted. type pepoleSorter struct { pepole []Pepole by func(p1, p2 *Pepole) bool // Closure used in the Less method. } // Len is part of sort.Interface. func (s *pepoleSorter) Len() int { return len(s.pepole) } // Swap is part of sort.Interface. func (s *pepoleSorter) Swap(i, j int) { s.pepole[i], s.pepole[j] = s.pepole[j], s.pepole[i] } // Less is part of sort.Interface. It is implemented by calling the \u0026#34;by\u0026#34; closure in the sorter. func (s *pepoleSorter) Less(i, j int) bool { return s.by(\u0026amp;s.pepole[i], \u0026amp;s.pepole[j]) } var pepole = []Pepole{ {\u0026#34;Rose\u0026#34;, 1.58, 66.6}, {\u0026#34;Daisley\u0026#34;, 1.78, 58.4}, {\u0026#34;Lumiya\u0026#34;, 1.65, 57.9}, {\u0026#34;Sola\u0026#34;, 1.68, 55.77}, } // ExampleSortKeys demonstrates a technique for sorting a struct type using programmable sort criteria. func Example_sortKeys() { // Closures that order the Planet structure.  name := func(p1, p2 *Pepole) bool { return p1.name \u0026lt; p2.name } stature := func(p1, p2 *Pepole) bool { return p1.h \u0026lt; p2.h } weight := func(p1, p2 *Pepole) bool { return p1.w \u0026lt; p2.w } decreasingWeight := func(p1, p2 *Pepole) bool { return !weight(p1, p2) } // Sort the pepole by the various criteria.  By(name).Sort(pepole) fmt.Println(\u0026#34;By name:\u0026#34;, pepole) By(stature).Sort(pepole) fmt.Println(\u0026#34;By stature:\u0026#34;, pepole) By(weight).Sort(pepole) fmt.Println(\u0026#34;By weight:\u0026#34;, pepole) By(decreasingWeight).Sort(pepole) fmt.Println(\u0026#34;By decreasing weight:\u0026#34;, pepole) // Output:  // By name: [{Daisley 1.78 58.4} {Lumiya 1.65 57.9} {Rose 1.58 66.6} {Sola 1.68 55.77}]  // By stature: [{Rose 1.58 66.6} {Lumiya 1.65 57.9} {Sola 1.68 55.77} {Daisley 1.78 58.4}]  // By weight: [{Sola 1.68 55.77} {Lumiya 1.65 57.9} {Daisley 1.78 58.4} {Rose 1.58 66.6}]  // By decreasing weight: [{Rose 1.58 66.6} {Daisley 1.78 58.4} {Lumiya 1.65 57.9} {Sola 1.68 55.77}] } 转自 golang切片排序sort包的使用\n"},{"id":33,"href":"/%E7%95%AA%E5%A4%96.%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/%E7%AD%89%E5%BE%85goroutine%E5%AE%8C%E6%88%90%E4%BB%BB%E5%8A%A1_%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8goroutine/","title":"等待goroutine完成任务 循环中使用goroutine","section":"番外.常用操作s","content":"简介 #  Goroutine 是 Golang 中非常有用的功能，有时候 goroutine 没执行完函数就返回了，如果希望等待当前的 goroutine 执行完成再接着往下执行，该怎么办？\npackage main import ( \u0026#34;time\u0026#34; \u0026#34;fmt\u0026#34; ) func say(s string) { for i := 0; i \u0026lt; 3; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(\u0026#34;hello world\u0026#34;) fmt.Println(\u0026#34;over!\u0026#34;) } 输出 over！ , 主线程没有等待\n唯一好方案 #  Golang 官方在 sync 包中提供了 WaitGroup 类型来解决这个问题。其文档描述如下：\n A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished.\n 大意为： WaitGroup 用来等待单个或多个 goroutines 执行结束。在主逻辑中使用 WaitGroup 的 Add 方法设置需要等待的 goroutines 的数量。在每个 goroutine 执行的函数中，需要调用 WaitGroup 的 Done 方法。最后在主逻辑中调用 WaitGroup 的 Wait 方法进行阻塞等待，直到所有 goroutine 执行完成。 使用方法可以总结为下面几点：\n 创建一个 WaitGroup 实例，比如名称为：wg 调用 wg.Add(n) ，其中 n 是等待的 goroutine 的数量 在每个 goroutine 运行的函数中执行 defer wg.Done() 调用 wg.Wait() 阻塞主逻辑  package main import ( \u0026#34;time\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func main() { var wg sync.WaitGroup wg.Add(2) say2(\u0026#34;hello\u0026#34;, \u0026amp;wg) say2(\u0026#34;world\u0026#34;, \u0026amp;wg) fmt.Println(\u0026#34;over!\u0026#34;) wg.Wait() } func say2(s string, waitGroup *sync.WaitGroup) { defer waitGroup.Done() for i := 0; i \u0026lt; 3; i++ { fmt.Println(s) } } 简短的例子，注意循环传入的变量用中间变量替代，防止闭包 bug\nvar wg sync.WaitGroup wg.Add(len(sList)) for _, d := range sList { tmpD := d go func(waitGroup *sync.WaitGroup) { defer waitGroup.Done() // to do something  // use tmpD  } }(\u0026amp;wg) } wg.Wait() 引用 #   Golang 入门 : 等待 goroutine 完成任务\n"}]